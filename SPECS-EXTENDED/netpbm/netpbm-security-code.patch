diff -ruNp a/analyzer/pgmtexture.c b/analyzer/pgmtexture.c
--- a/analyzer/pgmtexture.c	2021-06-02 15:53:59.866205957 +0200
+++ b/analyzer/pgmtexture.c	2021-06-02 16:13:04.906252648 +0200
@@ -54,6 +54,7 @@ vector(unsigned int const nl,
 
     assert(nh >= nl);
 
+    overflow_add(nh - nl, 1);
     MALLOCARRAY(v, (unsigned) (nh - nl + 1));
 
     if (v == NULL)
@@ -85,6 +86,7 @@ matrix (unsigned int const nrl,
     assert(nrh >= nrl);
 
     /* allocate pointers to rows */
+    overflow_add(nrh - nrl, 1);
     MALLOCARRAY(m, (unsigned) (nrh - nrl + 1));
     if (m == NULL)
         pm_error("Unable to allocate memory for a matrix.");
@@ -93,6 +95,7 @@ matrix (unsigned int const nrl,
 
     assert (nch >= ncl);
 
+    overflow_add(nch - ncl, 1);
     /* allocate rows and set pointers to them */
     for (i = nrl; i <= nrh; ++i) {
         MALLOCARRAY(m[i], (unsigned) (nch - ncl + 1));
diff -ruNp a/converter/other/gemtopnm.c b/converter/other/gemtopnm.c
--- a/converter/other/gemtopnm.c	2021-06-02 15:53:59.835205659 +0200
+++ b/converter/other/gemtopnm.c	2021-06-02 16:15:29.598641385 +0200
@@ -106,6 +106,7 @@ main(argc, argv)
 
     pnm_writepnminit( stdout, cols, rows, MAXVAL, type, 0 );
 
+    overflow_add(cols, padright);
     {
         /* allocate input row data structure */
         int plane;
diff -ruNp a/converter/other/jpegtopnm.c b/converter/other/jpegtopnm.c
--- a/converter/other/jpegtopnm.c	2021-06-02 15:53:59.833205640 +0200
+++ b/converter/other/jpegtopnm.c	2021-06-02 16:16:28.520206914 +0200
@@ -862,6 +862,8 @@ convertImage(FILE *
     /* Calculate output image dimensions so we can allocate space */
     jpeg_calc_output_dimensions(cinfoP);
 
+    overflow2(cinfoP->output_width, cinfoP->output_components);
+
     /* Start decompressor */
     jpeg_start_decompress(cinfoP);
 
diff -ruNp a/converter/other/pbmtopgm.c b/converter/other/pbmtopgm.c
--- a/converter/other/pbmtopgm.c	2021-06-02 15:53:59.831205621 +0200
+++ b/converter/other/pbmtopgm.c	2021-06-02 16:17:14.248645808 +0200
@@ -60,6 +60,7 @@ main(int argc, char *argv[]) {
 
 
     outrow = pgm_allocrow(cols) ;
+    overflow2(width, height);
     maxval = MIN(PGM_OVERALLMAXVAL, width*height);
     pgm_writepgminit(stdout, cols, rows, maxval, 0) ;
 
diff -ruNp a/converter/other/pnmtoddif.c b/converter/other/pnmtoddif.c
--- a/converter/other/pnmtoddif.c	2021-06-02 15:53:59.832205630 +0200
+++ b/converter/other/pnmtoddif.c	2021-06-02 16:18:17.064248709 +0200
@@ -629,6 +629,7 @@ main(int argc, char *argv[]) {
     switch (PNM_FORMAT_TYPE(format)) {
     case PBM_TYPE:
         ip.bits_per_pixel = 1;
+        overflow_add(cols, 7);
         ip.bytes_per_line = (cols + 7) / 8;
         ip.spectral = 2;
         ip.components = 1;
@@ -644,6 +645,7 @@ main(int argc, char *argv[]) {
         ip.polarity = 2;
         break;
     case PPM_TYPE:
+        overflow2(cols, 3);
         ip.bytes_per_line = 3 * cols;
         ip.bits_per_pixel = 24;
         ip.spectral = 5;
diff -ruNp a/converter/other/pnmtojpeg.c b/converter/other/pnmtojpeg.c
--- a/converter/other/pnmtojpeg.c	2021-06-02 15:53:59.835205659 +0200
+++ b/converter/other/pnmtojpeg.c	2021-06-02 19:57:44.413225834 +0200
@@ -606,7 +606,11 @@ read_scan_script(j_compress_ptr const ci
            want JPOOL_PERMANENT.
         */
         const unsigned int scan_info_size = nscans * sizeof(jpeg_scan_info);
-        jpeg_scan_info * const scan_info =
+        const jpeg_scan_info * scan_info;
+
+        overflow2(nscans, sizeof(jpeg_scan_info));
+
+        scan_info =
             (jpeg_scan_info *)
             (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
                                         scan_info_size);
@@ -938,6 +942,9 @@ compute_rescaling_array(JSAMPLE ** const
   const long half_maxval = maxval / 2;
   long val;
 
+  overflow_add(maxval, 1);
+  overflow2(maxval+1, sizeof(JSAMPLE));
+
   *rescale_p = (JSAMPLE *)
     (cinfo.mem->alloc_small) ((j_common_ptr) &cinfo, JPOOL_IMAGE,
                               (size_t) (((long) maxval + 1L) *
@@ -1016,6 +1023,7 @@ convert_scanlines(struct jpeg_compress_s
     */
 
   /* Allocate the libpnm output and compressor input buffers */
+  overflow2(cinfo_p->image_width, cinfo_p->input_components);
   buffer = (*cinfo_p->mem->alloc_sarray)
     ((j_common_ptr) cinfo_p, JPOOL_IMAGE,
      (unsigned int) cinfo_p->image_width * cinfo_p->input_components,
diff -ruNp a/converter/other/pnmtops.c b/converter/other/pnmtops.c
--- a/converter/other/pnmtops.c	2021-06-02 15:53:59.835205659 +0200
+++ b/converter/other/pnmtops.c	2021-06-02 20:02:06.055502227 +0200
@@ -294,17 +294,21 @@ parseCommandLine(int argc, const char **
     validateCompDimension(width, 72, "-width value");
     validateCompDimension(height, 72, "-height value");
 
+    overflow2(width, 72);
     cmdlineP->width  = width * 72;
+    overflow2(height, 72);
     cmdlineP->height = height * 72;
 
     if (imagewidthSpec) {
         validateCompDimension(imagewidth, 72, "-imagewidth value");
+        overflow2(imagewidth, 72);
         cmdlineP->imagewidth = imagewidth * 72;
     }
     else
         cmdlineP->imagewidth = 0;
     if (imageheightSpec) {
-        validateCompDimension(imagewidth, 72, "-imageheight value");
+        validateCompDimension(imageheight, 72, "-imageheight value");
+        overflow2(imageheight, 72);
         cmdlineP->imageheight = imageheight * 72;
     }
     else
diff -ruNp a/converter/other/rletopnm.c b/converter/other/rletopnm.c
--- a/converter/other/rletopnm.c	2021-06-02 15:53:59.834205650 +0200
+++ b/converter/other/rletopnm.c	2021-06-02 20:03:24.864187893 +0200
@@ -19,6 +19,8 @@
  * If you modify this software, you should include a notice giving the
  * name of the person performing the modification, the date of modification,
  * and the reason for such modification.
+ *
+ * 2002-12-19: Fix maths wrapping bugs. Alan Cox <alan@redhat.com>
  */
 /*
  * rletopnm - A conversion program to convert from Utah's "rle" image format
diff -ruNp a/converter/other/sirtopnm.c b/converter/other/sirtopnm.c
--- a/converter/other/sirtopnm.c	2021-06-02 15:53:59.833205640 +0200
+++ b/converter/other/sirtopnm.c	2021-06-02 20:03:50.280409024 +0200
@@ -69,6 +69,7 @@ char* argv[];
 	    }
 	    break;
 	case PPM_TYPE:
+        overflow3(cols, rows, 3);
 	    picsize = cols * rows * 3;
 	    planesize = cols * rows;
             if ( !( sirarray = (unsigned char*) malloc( picsize ) ) ) 
diff -ruNp a/converter/other/tifftopnm.c b/converter/other/tifftopnm.c
--- a/converter/other/tifftopnm.c	2021-06-02 15:53:59.834205650 +0200
+++ b/converter/other/tifftopnm.c	2021-06-02 20:04:47.721908789 +0200
@@ -1372,7 +1372,9 @@ convertRasterByRows(pnmOut *       const
     if (scanbuf == NULL)
         pm_error("can't allocate memory for scanline buffer");
 
-    MALLOCARRAY(samplebuf, cols * spp);
+    /* samplebuf is unsigned int * !!! */
+    samplebuf = (unsigned int *) malloc3(cols , sizeof(unsigned int) , spp);
+
     if (samplebuf == NULL)
         pm_error("can't allocate memory for row buffer");
 
diff -ruNp a/converter/other/xwdtopnm.c b/converter/other/xwdtopnm.c
--- a/converter/other/xwdtopnm.c	2021-06-02 15:53:59.833205640 +0200
+++ b/converter/other/xwdtopnm.c	2021-06-02 20:23:21.807634239 +0200
@@ -210,6 +210,10 @@ processX10Header(X10WDFileHeader *  cons
         *colorsP = pnm_allocrow(2);
         PNM_ASSIGN1((*colorsP)[0], 0);
         PNM_ASSIGN1((*colorsP)[1], *maxvalP);
+        overflow_add(h10P->pixmap_width, 15);
+        if(h10P->pixmap_width < 0)
+            pm_error("assert: negative width");
+        overflow2((((h10P->pixmap_width + 15) / 16) * 16 - h10P->pixmap_width), 8);
         *padrightP =
             (((h10P->pixmap_width + 15) / 16) * 16 - h10P->pixmap_width) * 8;
         *bits_per_itemP = 16;
@@ -635,6 +639,7 @@ processX11Header(X11WDFileHeader *  cons
 
     *colsP = h11FixedP->pixmap_width;
     *rowsP = h11FixedP->pixmap_height;
+    overflow2(h11FixedP->bytes_per_line, 8);
     *padrightP =
         h11FixedP->bytes_per_line * 8 -
         h11FixedP->pixmap_width * h11FixedP->bits_per_pixel;
diff -ruNp a/converter/pbm/mdatopbm.c b/converter/pbm/mdatopbm.c
--- a/converter/pbm/mdatopbm.c	2021-06-02 15:53:59.826205573 +0200
+++ b/converter/pbm/mdatopbm.c	2021-06-02 20:23:21.807634239 +0200
@@ -245,10 +245,13 @@ main(int argc, char **argv) {
         pm_readlittleshort(infile, &yy); nInCols = yy;
     }
     
+    overflow2(nOutCols, 8);
     nOutCols = 8 * nInCols;
     nOutRows = nInRows;
-    if (bScale) 
+    if (bScale) {
+        overflow2(nOutRows, 2);
         nOutRows *= 2;
+    }
 
     data = pbm_allocarray(nOutCols, nOutRows);
     
diff -ruNp a/converter/pbm/mgrtopbm.c b/converter/pbm/mgrtopbm.c
--- a/converter/pbm/mgrtopbm.c	2022-01-03 16:41:24.856969944 +0100
+++ b/converter/pbm/mgrtopbm.c	2022-01-03 16:43:27.023842152 +0100
@@ -105,6 +105,8 @@ readMgrHeader(FILE *          const ifP,
     interpHdrWidth (head, colsP);
     interpHdrHeight(head, rowsP);
 
+    overflow_add(*colsP, pad);
+
     *padrightP = ((*colsP + pad - 1) / pad) * pad - *colsP;
 }
 
diff --git a/converter/pbm/pbmto4425.c b/converter/pbm/pbmto4425.c
index 1d97ac6..c4c8cbb 100644
--- a/converter/pbm/pbmto4425.c
+++ b/converter/pbm/pbmto4425.c
@@ -2,6 +2,7 @@
 
 #include "nstring.h"
 #include "pbm.h"
+#include <string.h>
 
 static char bit_table[2][3] = {
 {1, 4, 0x10},
@@ -160,7 +161,7 @@ main(int argc, char * argv[]) {
     xres = vmap_width * 2;
     yres = vmap_height * 3;
 
-    vmap = malloc(vmap_width * vmap_height * sizeof(char));
+    vmap = malloc3(vmap_width, vmap_height, sizeof(char));
     if(vmap == NULL)
 	{
         pm_error( "Cannot allocate memory" );
diff --git a/converter/pbm/pbmtogem.c b/converter/pbm/pbmtogem.c
index 4fd30e9..c82757d 100644
--- a/converter/pbm/pbmtogem.c
+++ b/converter/pbm/pbmtogem.c
@@ -79,6 +79,7 @@ putinit (int const rows, int const cols)
   bitsperitem = 0;
   bitshift = 7;
   outcol = 0;
+  overflow_add(cols, 7);
   outmax = (cols + 7) / 8;
   outrow = (unsigned char *) pm_allocrow (outmax, sizeof (unsigned char));
   lastrow = (unsigned char *) pm_allocrow (outmax, sizeof (unsigned char));
diff -ruNp a/converter/pbm/pbmtogo.c b/converter/pbm/pbmtogo.c
--- a/converter/pbm/pbmtogo.c	2021-06-02 15:53:59.826205573 +0200
+++ b/converter/pbm/pbmtogo.c	2021-06-02 20:23:21.809634256 +0200
@@ -158,6 +158,7 @@ main(int           argc,
     bitrow = pbm_allocrow(cols);
 
     /* Round cols up to the nearest multiple of 8. */
+    overflow_add(cols, 7);
     rucols = ( cols + 7 ) / 8;
     bytesperrow = rucols;       /* GraphOn uses bytes */
     rucols = rucols * 8;
diff -ruNp a/converter/pbm/pbmtolj.c b/converter/pbm/pbmtolj.c
--- a/converter/pbm/pbmtolj.c	2021-06-02 15:53:59.828205592 +0200
+++ b/converter/pbm/pbmtolj.c	2021-06-02 20:23:21.810634265 +0200
@@ -120,7 +120,11 @@ parseCommandLine(int argc, char ** argv,
 static void
 allocateBuffers(unsigned int const cols) {
 
+    overflow_add(cols, 8);
     rowBufferSize = (cols + 7) / 8;
+    overflow_add(rowBufferSize, 128);
+    overflow_add(rowBufferSize, rowBufferSize+128);
+    overflow_add(rowBufferSize+10, rowBufferSize/8);
     packBufferSize = rowBufferSize + (rowBufferSize + 127) / 128 + 1;
     deltaBufferSize = rowBufferSize + rowBufferSize / 8 + 10;
 
diff -ruNp a/converter/pbm/pbmtomda.c b/converter/pbm/pbmtomda.c
--- a/converter/pbm/pbmtomda.c	2021-06-02 15:53:59.827205582 +0200
+++ b/converter/pbm/pbmtomda.c	2021-06-02 20:23:21.810634265 +0200
@@ -179,6 +179,7 @@ int main(int argc, char **argv)
     
     nOutRowsUnrounded = bScale ? nInRows/2 : nInRows;
 
+    overflow_add(nOutRowsUnrounded, 3);
     nOutRows = ((nOutRowsUnrounded + 3) / 4) * 4;
         /* MDA wants rows a multiple of 4 */   
     nOutCols = nInCols / 8;
diff -ruNp a/converter/pbm/pbmtoppa/pbm.c b/converter/pbm/pbmtoppa/pbm.c
--- a/converter/pbm/pbmtoppa/pbm.c	2021-06-02 15:53:59.830205611 +0200
+++ b/converter/pbm/pbmtoppa/pbm.c	2021-06-02 20:23:21.811634274 +0200
@@ -11,185 +11,128 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <limits.h>
 
-#include "pm.h"
-#include "nstring.h"
 #include "ppapbm.h"
 
-int
-make_pbm_stat(pbm_stat * const pbmStatP,
-              FILE *     const ifP) {
-
-    char line[1024];
-    char * rc;
-    int retval;
-
-    pbmStatP->fptr         = ifP;
-    pbmStatP->version      = none;
-    pbmStatP->current_line = 0;
-    pbmStatP->unread       = 0;
-
-    rc = fgets(line, 1024, ifP);
-    if (rc == NULL)
-        retval = 0;
-    else {
-        line[strlen(line)-1] = 0;
-
-        if (streq(line,"P1"))
-            pbmStatP->version=P1;
-        if (streq(line,"P4"))
-            pbmStatP->version=P4;
-
-        if (pbmStatP->version == none) {
-            pm_message("unknown PBM magic '%s'", line);
-            retval = 0;
-        } else {
-            do {
-                char * rc;
-                rc = fgets(line, 1024, ifP);
-                if (rc == NULL)
-                    return 0;
-            } while (line[0] == '#');
-            {
-                int rc;
-                rc = sscanf(line, "%d %d",
-                            &pbmStatP->width, &pbmStatP->height);
-                if (rc != 2)
-                    retval = 0;
-                else {
-                    if (pbmStatP->width < 0) {
-                        pm_message("Image has negative width");
-                        retval = 0;
-                    } else if (pbmStatP->width > INT_MAX/2) {
-                        pm_message("Uncomputeably large width: %d",
-                                   pbmStatP->width);
-                        retval = 0;
-                    } else if (pbmStatP->height < 0) {
-                        pm_message("Image has negative height");
-                        retval = 0;
-                    } else if (pbmStatP->height > INT_MAX/2) {
-                        pm_message("Uncomputeably large height: %d",
-                                   pbmStatP->height);
-                        retval = 0;
-                    } else
-                        retval = 1;
-                }
-            }
-        }
-    }
-    return retval;
-}
+int make_pbm_stat(pbm_stat* pbm,FILE* fptr)
+{
+  char line[1024];
 
+  pbm->fptr=fptr;
+  pbm->version=none;
+  pbm->current_line=0;
+  pbm->unread = 0;
 
+  if (fgets (line, 1024, fptr) == NULL)
+    return 0;
+  line[strlen(line)-1] = 0;
 
-static int
-getbytes(FILE *          const ifP,
-         unsigned int    const width,
-         unsigned char * const data) {
-
-    unsigned char mask;
-    unsigned char acc;
-    unsigned char * place;
-    unsigned int num;
-    int retval;
-
-    if (width == 0)
-        retval = 0;
-    else {
-        for (mask = 0x80, acc = 0, num = 0, place = data; num < width; ) {
-            switch (getc(ifP)) {
-            case EOF:
-                return 0;
-            case '1':
-                acc |= mask;
-                /* fall through */
-            case '0':
-                mask >>= 1;
-                ++num;
-                if (mask == 0x00) { /* if (num % 8 == 0) */
-                    *place++ = acc;
-                    acc = 0;
-                    mask = 0x80;
-                }
-            }
-        }
-        if (width % 8 != 0)
-            *place = acc;
-
-        retval = 1;
-    }
-    return retval;
-}
+  if(!strcmp(line,"P1")) pbm->version=P1;
+  if(!strcmp(line,"P4")) pbm->version=P4;
+  if(pbm->version == none)
+  {
+    fprintf(stderr,"pbm_readheader(): unknown PBM magic '%s'\n",line);
+    return 0;
+  }
 
+  do
+    if (fgets (line, 1024, fptr) == NULL)
+      return 0;
+  while (line[0] == '#');
 
+  if (2 != sscanf (line, "%d %d", &pbm->width, &pbm->height))
+    return 0;
 
-int
-pbm_readline(pbm_stat *      const pbmStatP,
-             unsigned char * const data) {
-/*----------------------------------------------------------------------------
-  Read a single line into data which must be at least (pbmStatP->width+7)/8
-  bytes of storage.
------------------------------------------------------------------------------*/
-    int retval;
-
-    if (pbmStatP->current_line >= pbmStatP->height)
-        retval = 0;
-    else {
-        if (pbmStatP->unread) {
-            memcpy(data, pbmStatP->revdata, (pbmStatP->width+7)/8);
-            ++pbmStatP->current_line;
-            pbmStatP->unread = 0;
-            free(pbmStatP->revdata);
-            pbmStatP->revdata = NULL;
-            retval = 1;
-        } else {
-            switch (pbmStatP->version) {
-            case P1:
-                if (getbytes(pbmStatP->fptr, pbmStatP->width, data)) {
-                    pbmStatP->current_line++;
-                    retval = 1;
-                } else
-                    retval = 0;
-                break;
-            case P4: {
-                int tmp, tmp2;
-                tmp = (pbmStatP->width+7)/8;
-                tmp2 = fread(data,1,tmp,pbmStatP->fptr);
-                if (tmp2 == tmp) {
-                    ++pbmStatP->current_line;
-                    retval = 1;
-                } else {
-                    pm_message("error reading line data (%d)", tmp2);
-                    retval = 0;
-                }
-            } break;
-
-            default:
-                pm_message("unknown PBM version");
-                retval = 0;
-            }
-        }
-    }
-    return retval;
+  return 1;
 }
 
+static int getbytes(FILE *fptr,int width,unsigned char* data)
+{
+  unsigned char mask,acc,*place;
+  int num;
+
+  if(!width) return 0;
+  for(mask=0x80, acc=0, num=0, place=data; num<width; )
+  {
+    switch(getc(fptr))
+    {
+    case EOF:      
+      return 0;
+    case '1':
+      acc|=mask;
+      /* fall through */
+    case '0':
+      mask>>=1;
+      num++;
+      if(!mask) /* if(num%8 == 0) */
+      {
+	*place++ = acc;
+	acc=0;
+	mask=0x80;
+      }
+    }
+  }
+  if(width%8)
+    *place=acc;
+  return 1;
+}
 
+/* Reads a single line into data which must be at least (pbm->width+7)/8
+   bytes of storage */
+int pbm_readline(pbm_stat* pbm,unsigned char* data)
+{
+  int tmp,tmp2;
+
+  if(pbm->current_line >= pbm->height) return 0;
+
+  if (pbm->unread)
+    {
+      memcpy (data, pbm->revdata, (pbm->width+7)/8);
+      pbm->current_line++;
+      pbm->unread = 0;
+      free (pbm->revdata);
+      pbm->revdata = NULL;
+      return 1;
+    }
 
-void
-pbm_unreadline(pbm_stat * const pbmStatP,
-               void *     const data) {
-/*----------------------------------------------------------------------------
-  Push a line back into the buffer; we read too much!
------------------------------------------------------------------------------*/
-    /* can store only one line in the unread buffer */
-
-    if (!pbmStatP->unread) {
-        pbmStatP->unread = 1;
-        pbmStatP->revdata = malloc ((pbmStatP->width+7)/8);
-        memcpy(pbmStatP->revdata, data, (pbmStatP->width+7)/8);
-        --pbmStatP->current_line;
+  switch(pbm->version)
+  {
+  case P1:
+    if(getbytes(pbm->fptr,pbm->width,data))
+    {
+      pbm->current_line++;
+      return 1;
     }
-}
+    return 0;
+
+  case P4:
+    overflow_add(pbm->width, 7);
+    tmp=(pbm->width+7)/8;
+    tmp2=fread(data,1,tmp,pbm->fptr);
+    if(tmp2 == tmp)
+    {
+      pbm->current_line++;
+      return 1;
+    }
+    fprintf(stderr,"pbm_readline(): error reading line data (%d)\n",tmp2);
+    return 0;
 
+  default:
+    fprintf(stderr,"pbm_readline(): unknown PBM version\n");
+    return 0;
+  }
+}
 
+/* push a line back into the buffer; we read too much! */
+void pbm_unreadline (pbm_stat *pbm, void *data)
+{
+  /* can only store one line in the unread buffer */
+  if (pbm->unread)
+    return;
+
+  pbm->unread = 1;
+  overflow_add(pbm->width, 7);
+  pbm->revdata = malloc ((pbm->width+7)/8);
+  memcpy (pbm->revdata, data, (pbm->width+7)/8);
+  pbm->current_line--;
+}
diff -ruNp a/converter/pbm/pbmtoppa/pbmtoppa.c b/converter/pbm/pbmtoppa/pbmtoppa.c
--- a/converter/pbm/pbmtoppa/pbmtoppa.c	2021-06-02 15:53:59.829205601 +0200
+++ b/converter/pbm/pbmtoppa/pbmtoppa.c	2021-06-02 20:23:21.811634274 +0200
@@ -453,6 +453,7 @@ main(int argc, char *argv[]) {
             pm_error("main(): unrecognized parameter '%s'", argv[argn]);
     }
 
+    overflow_add(Width, 7);
     Pwidth=(Width+7)/8;
     printer.fptr=out;
 
diff -ruNp a/converter/pbm/pbmtoxbm.c b/converter/pbm/pbmtoxbm.c
--- a/converter/pbm/pbmtoxbm.c	2021-06-02 15:53:59.829205601 +0200
+++ b/converter/pbm/pbmtoxbm.c	2021-06-02 20:23:21.812634282 +0200
@@ -352,6 +352,8 @@ convertRaster(FILE *          const ifP,
 
     unsigned char * bitrow;
     unsigned int row;
+    
+    overflow_add(cols, padright);
 
     putinit(xbmVersion);
 
diff --git a/converter/pbm/pktopbm.c b/converter/pbm/pktopbm.c
index 712f339..b6fcb02 100644
--- a/converter/pbm/pktopbm.c
+++ b/converter/pbm/pktopbm.c
@@ -280,6 +280,7 @@ main(int argc, char *argv[]) {
         if (flagbyte == 7) {            /* long form preamble */
             integer packetlength = get32() ;    /* character packet length */
             car = get32() ;         /* character number */
+            overflow_add(packetlength, pktopbm_pkloc);
             endofpacket = packetlength + pktopbm_pkloc;
                 /* calculate end of packet */
             if ((car >= MAXPKCHAR) || !filename[car]) {
diff -ruNp a/converter/pbm/thinkjettopbm.l b/converter/pbm/thinkjettopbm.l
--- a/converter/pbm/thinkjettopbm.l	2021-06-02 15:53:59.828205592 +0200
+++ b/converter/pbm/thinkjettopbm.l	2021-06-02 20:23:21.813634291 +0200
@@ -114,7 +114,9 @@ DIG             [0-9]
 <RASTERMODE>\033\*b{DIG}+W  {
                             int l;
                             if (rowCount >= rowCapacity) {
-                                rowCapacity += 100;
+				overflow_add(rowCapacity, 100);
+                                 rowCapacity += 100;
+				overflow2(rowCapacity, sizeof *rows);
                                 rows = realloc (rows, rowCapacity * sizeof *rows);
                                 if (rows == NULL)
                                     pm_error ("Out of memory.");
@@ -226,6 +228,8 @@ yywrap (void)
     /*
      * Quite simple since ThinkJet bit arrangement matches PBM
      */
+
+    overflow2(maxRowLength, 8);
     pbm_writepbminit(stdout, maxRowLength*8, rowCount, 0);
 
     packed_bitrow = malloc(maxRowLength);
diff -ruNp a/converter/pbm/ybmtopbm.c b/converter/pbm/ybmtopbm.c
--- a/converter/pbm/ybmtopbm.c	2022-01-03 16:41:24.857969951 +0100
+++ b/converter/pbm/ybmtopbm.c	2022-01-03 16:42:59.671646876 +0100
@@ -49,6 +49,8 @@ getinit(FILE *         const ifP,
     *colsP = (unsigned int) cols;
     *rowsP = (unsigned int) rows;
     *depthP = 1;
+
+    overflow_add(*colsP, 15);
 }
 
 
diff -ruNp a/converter/pgm/lispmtopgm.c b/converter/pgm/lispmtopgm.c
--- a/converter/pgm/lispmtopgm.c	2021-06-02 15:53:59.831205621 +0200
+++ b/converter/pgm/lispmtopgm.c	2021-06-02 20:23:21.814634300 +0200
@@ -58,6 +58,7 @@ main( argc, argv )
         pm_error( "depth (%d bits) is too large", depth);
 
     pgm_writepgminit( stdout, cols, rows, (gray) maxval, 0 );
+    overflow_add(cols, 7);
     grayrow = pgm_allocrow( ( cols + 7 ) / 8 * 8 );
 
     for ( row = 0; row < rows; ++row )
@@ -102,6 +103,8 @@ getinit( file, colsP, rowsP, depthP, pad
     
     if ( *depthP == 0 )
 	*depthP = 1;	/* very old file */
+
+    overflow_add((int)colsP, 31);
     
     *padrightP = ( ( *colsP + 31 ) / 32 ) * 32 - *colsP;
     
diff -ruNp a/converter/pgm/psidtopgm.c b/converter/pgm/psidtopgm.c
--- a/converter/pgm/psidtopgm.c	2021-06-02 15:53:59.830205611 +0200
+++ b/converter/pgm/psidtopgm.c	2021-06-02 20:23:21.815634309 +0200
@@ -78,6 +78,7 @@ main(int     argc,
         pm_error("bits/sample (%d) is too large.", bitspersample);
 
     pgm_writepgminit(stdout, cols, rows, maxval, 0);
+    overflow_add(cols, 7);
     grayrow = pgm_allocrow((cols + 7) / 8 * 8);
     for (row = 0; row < rows; ++row) {
         unsigned int col;
diff --git a/converter/ppm/Makefile b/converter/ppm/Makefile
index 003ef8d..b97349d 100644
--- a/converter/ppm/Makefile
+++ b/converter/ppm/Makefile
@@ -11,7 +11,7 @@ SUBDIRS = hpcdtoppm ppmtompeg
 
 PORTBINARIES =	411toppm eyuvtoppm gouldtoppm ilbmtoppm imgtoppm \
 		leaftoppm mtvtoppm neotoppm \
-		pcxtoppm pc1toppm pi1toppm picttoppm pjtoppm \
+		pcxtoppm pc1toppm pi1toppm pjtoppm \
 		ppmtoacad ppmtoapplevol ppmtoarbtxt ppmtoascii \
 		ppmtobmp ppmtoeyuv ppmtogif ppmtoicr ppmtoilbm \
 		ppmtoleaf ppmtolj ppmtomitsu ppmtoneo \
diff --git a/converter/ppm/ilbmtoppm.c b/converter/ppm/ilbmtoppm.c
index b9b8986..f4fe331 100644
--- a/converter/ppm/ilbmtoppm.c
+++ b/converter/ppm/ilbmtoppm.c
@@ -608,6 +608,7 @@ decode_row(FILE *          const ifP,
     rawtype *chp;
 
     cols = bmhdP->w;
+    overflow_add(cols, 15);
     bytes = RowBytes(cols);
     for( plane = 0; plane < nPlanes; plane++ ) {
         int mask;
@@ -695,6 +696,23 @@ decode_mask(FILE *          const ifP,
  Multipalette handling
  ****************************************************************************/
 
+static void *
+xmalloc2(x, y)
+    int x;
+    int y;
+{
+    void *mem;
+
+    overflow2(x,y);
+    if( x * y == 0 )
+        return NULL;
+
+    mem = malloc2(x,y);
+    if( mem == NULL )
+        pm_error("out of memory allocating %d bytes", x * y);
+    return mem;
+}
+
 
 static void
 multi_adjust(ColorMap *            const cmapP,
@@ -1363,6 +1381,9 @@ dcol_to_ppm(FILE *         const ifP,
     if( redmaxval != maxval || greenmaxval != maxval || bluemaxval != maxval )
         pm_message("scaling colors to %d bits", pm_maxvaltobits(maxval));
 
+    overflow_add(redmaxval, 1);
+    overflow_add(greenmaxval, 1);
+    overflow_add(bluemaxval, 1);
     MALLOCARRAY_NOFAIL(redtable,   redmaxval   +1);
     MALLOCARRAY_NOFAIL(greentable, greenmaxval +1);
     MALLOCARRAY_NOFAIL(bluetable,  bluemaxval  +1);
@@ -1802,7 +1823,9 @@ PCHG_ConvertSmall(PCHGHeader *    const
             ChangeCount32 = *data++;
             remDataSize -= 2;
 
+            overflow_add(ChangeCount16, ChangeCount32);
             changes = ChangeCount16 + ChangeCount32;
+            overflow_add(changes, 1);
             for (i = 0; i < changes; ++i) {
                 if (totalchanges >= pchgP->TotalChanges) goto fail;
                 if (remDataSize < 2) goto fail;
@@ -2067,6 +2090,9 @@ read_pchg(FILE *     const ifP,
             cmap->mp_change[i] = NULL;
         if( PCHG.StartLine < 0 ) {
             int nch;
+            if(PCHG.MaxReg < PCHG.MinReg)
+                pm_error("assert: MinReg > MaxReg");
+            overflow_add(PCHG.MaxReg-PCHG.MinReg, 2);
             nch = PCHG.MaxReg - PCHG.MinReg +1;
             MALLOCARRAY_NOFAIL(cmap->mp_init, nch + 1);
             for( i = 0; i < nch; i++ )
@@ -2143,6 +2169,7 @@ process_body( FILE *          const ifP,
     if (typeid == ID_ILBM) {
         int isdeep;
 
+        overflow_add(bmhdP->w, 15);
         MALLOCARRAY_NOFAIL(ilbmrow, RowBytes(bmhdP->w));
         *viewportmodesP |= fakeviewport;      /* -isham/-isehb */
 
diff -ruNp a/converter/ppm/imgtoppm.c b/converter/ppm/imgtoppm.c
--- a/converter/ppm/imgtoppm.c	2021-06-02 15:53:59.845205755 +0200
+++ b/converter/ppm/imgtoppm.c	2021-06-02 20:23:21.818634335 +0200
@@ -84,6 +84,7 @@ main(int argc, char ** argv) {
             len = atoi((char*) buf );
             if ( fread( buf, len, 1, ifp ) != 1 )
                 pm_error( "bad colormap buf" );
+            overflow2(cmaplen, 3);
             if ( cmaplen * 3 != len )
             {
                 pm_message(
@@ -105,6 +106,7 @@ main(int argc, char ** argv) {
                 pm_error( "bad pixel data header" );
             buf[8] = '\0';
             len = atoi((char*) buf );
+            overflow2(cols, rows);
             if ( len != cols * rows )
                 pm_message(
                     "pixel data length (%d) does not match image size (%d)",
diff --git a/converter/ppm/pcxtoppm.c b/converter/ppm/pcxtoppm.c
index e252ba2..270ae3b 100644
--- a/converter/ppm/pcxtoppm.c
+++ b/converter/ppm/pcxtoppm.c
@@ -409,6 +409,7 @@ pcx_planes_to_pixels(pixels, bitplanes, bytesperline, planes, bitsperpixel)
     /*
      * clear the pixel buffer
      */
+    overflow2(bytesperline, 8);
     npixels = (bytesperline * 8) / bitsperpixel;
     p    = pixels;
     while (--npixels >= 0)
@@ -470,6 +471,7 @@ pcx_16col_to_ppm(FILE *       const ifP,
     }
 
     /*  BytesPerLine should be >= BitsPerPixel * cols / 8  */
+    overflow2(BytesPerLine, 8);
     rawcols = BytesPerLine * 8 / BitsPerPixel;
     if (headerCols > rawcols) {
         pm_message("warning - BytesPerLine = %d, "
diff -ruNp a/converter/ppm/picttoppm.c b/converter/ppm/picttoppm.c
--- a/converter/ppm/picttoppm.c	2021-06-02 15:53:59.845205755 +0200
+++ b/converter/ppm/picttoppm.c	2021-06-02 20:23:21.820634352 +0200
@@ -1,3 +1,4 @@
+#error "Unfixable. Don't ship me"
 /*
  * picttoppm.c -- convert a MacIntosh PICT file to PPM format.
  *
diff -ruNp a/converter/ppm/pjtoppm.c b/converter/ppm/pjtoppm.c
--- a/converter/ppm/pjtoppm.c	2021-06-02 15:53:59.845205755 +0200
+++ b/converter/ppm/pjtoppm.c	2021-06-02 20:23:21.821634361 +0200
@@ -10,98 +10,66 @@
 ** implied warranty.
 */
 
-#include <stdbool.h>
-
 #include "ppm.h"
-#include "pm_c_util.h"
 #include "mallocvar.h"
 
 static char usage[] =  "[paintjetfile]";
 
-
-
-static unsigned int
-uintProduct(unsigned int const multiplicand,
-            unsigned int const multiplier) {
-
-    if (UINT_MAX / multiplier < multiplicand)
-        pm_error("Airthmetic overflow");
-
-    return multiplicand * multiplier;
-}
-
-
-
+static int egetc ARGS((FILE *fp));
 static int
-egetc(FILE * const ifP) {
+egetc(fp)
+    FILE *fp;
+{
     int c;
-
-    c = fgetc(ifP);
-
-    if (c == -1)
+    if ((c = fgetc(fp)) == -1)
         pm_error("unexpected end of file");
-
-    return c;
+    return(c);
 }
 
-
-
 int
-main(int argc, const char ** argv) {
-
+main(argc, argv)
+    int argc;
+    char *argv[];
+{
     int cmd, val;
     char buffer[BUFSIZ];
-    int planes = 3;
-    unsigned int rows;
-    unsigned int rowsX;
-    unsigned int cols;
-    bool colsIsSet;
+    int planes = 3, rows = -1, cols = -1;
+    int r = 0, c = 0, p = 0, i;
     unsigned char **image = NULL;
     int *imlen;
-    FILE * ifP;
+    FILE *fp = stdin;
     int mode;
-    bool modeIsSet;
     int argn;
     unsigned char bf[3];
-    pixel * pixrow;
-    int c;
-    int row;
-    int plane;
+    pixel *pixrow;
 
-    pm_proginit(&argc, argv);
 
+    ppm_init(&argc, argv);
     argn = 1;
     if (argn != argc)
-        ifP = pm_openr(argv[argn++]);
+        fp = pm_openr(argv[argn++]);
     else
-        ifP = stdin;
+        fp = stdin;
 
     if (argn != argc)
         pm_usage(usage);
 
-    row = 0;  /* initial value */
-    plane = 0;  /* initial value */
-    modeIsSet = false;  /* initial value */
-    colsIsSet = false;  /* initial value */
-    rowsX = 0;  /* initial value */
-
-    while ((c = fgetc(ifP)) != -1) {
+    while ((c = fgetc(fp)) != -1) {
         if (c != '\033')
             continue;
-        switch (c = egetc(ifP)) {
+        switch (c = egetc(fp)) {
         case 'E':   /* reset */
             break;
-        case '*': {
-            unsigned int i;
-            cmd = egetc(ifP);
+        case '*':
+            cmd = egetc(fp);
             for (i = 0; i < BUFSIZ; i++) {
-                if (!isdigit(c = egetc(ifP)) && c != '+' && c != '-')
+                if (!isdigit(c = egetc(fp)) && c != '+' && c != '-')
                     break;
                 buffer[i] = c;
             }
             if (i != 0) {
                 buffer[i] = '\0';
-                if (sscanf(buffer, "%d", &val) != 1)
+                if (sscanf(buffer, "%d", &val) != 1) 
                     pm_error("bad value `%s' at <ESC>*%c%c", buffer, cmd, c);
             }
             else
@@ -125,18 +93,18 @@ main(int argc, const char ** argv) {
             case 'r':
                 switch (c) {
                 case 'S':   /* width */
-                    if (val < 0)
+                    if (val < 0) {
                         pm_error("invalid width value");
-                    else {
+                    } else {
                         cols = val;
-                        colsIsSet = true;
                     }
                     break;
                 case 'T':   /* height */
-                    if (val < 0)
+                    if (val < 0) {
                         pm_error ("invalid height value");
-                    else
-                        rowsX = val;
+                    } else {
+                        rows = val;
+                    }
                     break;
                 case 'U':   /* planes */
                     planes = val;
@@ -163,40 +131,43 @@ main(int argc, const char ** argv) {
                     if (val != 0 && val != 1)
                         pm_error("unimplemented transmission mode %d", val);
                     mode = val;
-                    modeIsSet = true;
                     break;
                 case 'V':   /* send plane */
                 case 'W':   /* send last plane */
-                    if (row >= rowsX || image == NULL) {
-                        if (row >= rowsX)
-                            rowsX += 100;
+                    if (rows == -1 || r >= rows || image == NULL) {
+                        if (rows == -1 || r >= rows) {
+                            overflow_add(rows, 100);
+                            rows += 100;
+                        }
+
                         if (image == NULL) {
-                            MALLOCARRAY(image, uintProduct(rowsX, planes));
-                            MALLOCARRAY(imlen, uintProduct(rowsX, planes));
-                        } else {
-                            REALLOCARRAY(image, uintProduct(rowsX, planes));
-                            REALLOCARRAY(imlen, uintProduct(rowsX, planes));
+                            image = (unsigned char **)
+                                malloc3(rows , planes , sizeof(unsigned char *));
+                            imlen = (int *) malloc3(rows , planes,  sizeof(int));
                         }
+                        else {
+                            overflow2(rows,planes);
+                            image = (unsigned char **)
+                                realloc2(image, rows * planes,
+                                    sizeof(unsigned char *));
+                            imlen = (int *) realloc2(imlen, rows * planes, sizeof(int));                        }
                     }
                     if (image == NULL || imlen == NULL)
                         pm_error("out of memory");
-                    if (plane >= planes)
+                    if (p == planes) 
                         pm_error("too many planes");
-                    if (!colsIsSet)
-                        pm_error("missing width value");
-
-                    cols = MAX(cols, val);
-                    imlen[row * planes + plane] = val;
-                    MALLOCARRAY(image[row * planes + plane], val);
-                    if (image[row * planes + plane] == NULL)
+                    cols = cols > val ? cols : val;
+                    imlen[r * planes + p] = val;
+                    MALLOCARRAY(image[r * planes + p], val);
+                    if (image[r * planes + p] == NULL) 
                         pm_error("out of memory");
-                    if (fread(image[row * planes + plane], 1, val, ifP) != val)
+                    if (fread(image[r * planes + p], 1, val, fp) != val) 
                         pm_error("short data");
                     if (c == 'V')
-                        ++plane;
+                        p++;
                     else {
-                        plane = 0;
-                        ++row;
+                        p = 0;
+                        r++;
                     }
                     break;
                 default:
@@ -205,7 +176,7 @@ main(int argc, const char ** argv) {
                 }
                 break;
             case 'p': /* Position */
-                if (plane != 0)
+                if (p != 0) 
                     pm_error("changed position in the middle of "
                              "transferring planes");
                 switch (c) {
@@ -214,15 +185,15 @@ main(int argc, const char ** argv) {
                     break;
                 case 'Y':
                     if (buffer[0] == '+')
-                        val = row + val;
+                        val = r + val;
                     if (buffer[0] == '-')
-                        val = row - val;
-                    for (; val > row; ++row)
-                        for (plane = 0; plane < 3; ++plane) {
-                            imlen[row * planes + plane] = 0;
-                            image[row * planes + plane] = NULL;
+                        val = r - val;
+                    for (; val > r; r++) 
+                        for (p = 0; p < 3; p++) {
+                            imlen[r * planes + p] = 0;
+                            image[r * planes + p] = NULL;
                         }
-                    row = val;
+                    r = val;
                     break;
                 default:
                     pm_message("uninmplemented <ESC>*%c%d%c", cmd, val, c);
@@ -231,86 +202,65 @@ main(int argc, const char ** argv) {
             default:
                 pm_message("uninmplemented <ESC>*%c%d%c", cmd, val, c);
                 break;
-             }
-        } /* case */
-        } /* switch */
+            }
+        }
     }
-    pm_close(ifP);
-
-    if (!modeIsSet)
-        pm_error("Input does not contain a 'bM' transmission mode order");
-
-    rows = row;
+    pm_close(fp);
+    rows = r;
     if (mode == 1) {
-        unsigned int const newcols = 10240;
-            /* It could not be larger than that! */
-
-        unsigned char * buf;
-        unsigned int row;
-
-        for (row = 0, cols = 0; row < rows; ++row) {
-            unsigned int plane;
-            if (image[row * planes] == NULL)
+        unsigned char *buf;
+        int newcols = 0;
+        newcols = 10240; /* It could not be larger that that! */
+        cols = 0;
+        for (r = 0; r < rows; r++) {
+            if (image[r * planes] == NULL)
                 continue;
-            for (plane = 0; plane < planes; ++plane) {
-                unsigned int i;
-                unsigned int col;
+            for (p = 0; p < planes; p++) {
                 MALLOCARRAY(buf, newcols);
-                if (buf == NULL)
+                if (buf == NULL) 
                     pm_error("out of memory");
-                for (i = 0, col = 0;
-                     col < imlen[plane + row * planes];
-                     col += 2)
-                    for (cmd = image[plane + row * planes][col],
-                             val = image[plane + row * planes][col+1];
-                         cmd >= 0 && i < newcols; cmd--, i++)
+                for (i = 0, c = 0; c < imlen[p + r * planes]; c += 2)
+                    for (cmd = image[p + r * planes][c],
+                             val = image[p + r * planes][c+1]; 
+                         cmd >= 0 && i < newcols; cmd--, i++) {
                         buf[i] = val;
-                cols = MAX(cols, i);
-                free(image[plane + row * planes]);
-                /*
-                 * This is less than what we have so it realloc should
+                        overflow_add(i, 1);
+                    }
+                cols = cols > i ? cols : i;
+                free(image[p + r * planes]);
+                /* 
+                 * This is less than what we have so it realloc should 
                  * not return null. Even if it does, tough! We will
                  * lose a line, and probably die on the next line anyway
                  */
-                image[plane + row * planes] = realloc(buf, i);
+                image[p + r * planes] = (unsigned char *) realloc(buf, i);
             }
         }
+        overflow2(cols, 8);
         cols *= 8;
     }
-
+            
+       
     ppm_writeppminit(stdout, cols, rows, (pixval) 255, 0);
     pixrow = ppm_allocrow(cols);
-
-    for (row = 0; row < rows; ++row) {
-        if (image[row * planes] == NULL) {
-            unsigned int col;
-            for (col = 0; col < cols; ++col)
-                PPM_ASSIGN(pixrow[col], 0, 0, 0);
+    for (r = 0; r < rows; r++) {
+        if (image[r * planes] == NULL) {
+            for (c = 0; c < cols; c++)
+                PPM_ASSIGN(pixrow[c], 0, 0, 0);
             continue;
         }
-        {
-            unsigned int col;
-            unsigned int cmd;
-            for (cmd = 0, col = 0; col < cols; col += 8, ++cmd) {
-                unsigned int i;
-                for (i = 0; i < 8 && col + i < cols; ++i) {
-                    unsigned int plane;
-                    for (plane = 0; plane < planes; ++plane)
-                        if (mode == 0 && cmd >= imlen[row * planes + plane])
-                            bf[plane] = 0;
-                        else
-                            bf[plane] = (image[row * planes + plane][cmd] &
-                                     (1 << (7 - i))) ? 255 : 0;
-                    PPM_ASSIGN(pixrow[col + i], bf[0], bf[1], bf[2]);
-                }
+        for (cmd = 0, c = 0; c < cols; c += 8, cmd++) 
+            for (i = 0; i < 8 && c + i < cols; i++) {
+                for (p = 0; p < planes; p++) 
+                    if (mode == 0 && cmd >= imlen[r * planes + p])
+                        bf[p] = 0;
+                    else
+                        bf[p] = (image[r * planes + p][cmd] & 
+                                 (1 << (7 - i))) ? 255 : 0;
+                PPM_ASSIGN(pixrow[c + i], bf[0], bf[1], bf[2]);
             }
-        }
-        ppm_writeppmrow(stdout, pixrow, cols, 255, 0);
+        ppm_writeppmrow(stdout, pixrow, cols, (pixval) 255, 0);
     }
     pm_close(stdout);
-
-    return 0;
+    exit(0);
 }
-
-
-
diff -ruNp a/converter/ppm/ppmtoeyuv.c b/converter/ppm/ppmtoeyuv.c
--- a/converter/ppm/ppmtoeyuv.c	2021-06-02 15:53:59.845205755 +0200
+++ b/converter/ppm/ppmtoeyuv.c	2021-06-02 20:23:21.821634361 +0200
@@ -114,6 +114,7 @@ create_multiplication_tables(const pixva
 
     int index;
 
+    overflow_add(maxval, 1);
     MALLOCARRAY_NOFAIL(mult299   , maxval+1);
     MALLOCARRAY_NOFAIL(mult587   , maxval+1);
     MALLOCARRAY_NOFAIL(mult114   , maxval+1);
diff -ruNp a/converter/ppm/ppmtolj.c b/converter/ppm/ppmtolj.c
--- a/converter/ppm/ppmtolj.c	2021-06-02 15:53:59.846205765 +0200
+++ b/converter/ppm/ppmtolj.c	2021-06-02 20:23:21.821634361 +0200
@@ -182,6 +182,7 @@ int main(int argc, char *argv[]) {
     ppm_readppminit( ifp, &cols, &rows, &maxval, &format );
     pixelrow = ppm_allocrow( cols );
 
+    overflow2(cols, 6);
     obuf = (unsigned char *) pm_allocrow(cols * 3, sizeof(unsigned char));
     cbuf = (unsigned char *) pm_allocrow(cols * 6, sizeof(unsigned char));
     if (mode == C_TRANS_MODE_DELTA)
diff -ruNp a/converter/ppm/ppmtomitsu.c b/converter/ppm/ppmtomitsu.c
--- a/converter/ppm/ppmtomitsu.c	2021-06-02 15:53:59.846205765 +0200
+++ b/converter/ppm/ppmtomitsu.c	2021-06-02 20:23:21.822634370 +0200
@@ -685,6 +685,8 @@ main(int argc, char * argv[]) {
         medias = MSize_User;
 
     if (dpi300) {
+        overflow2(medias.maxcols, 2);
+        overflow2(medias.maxrows, 2);
         medias.maxcols *= 2;
         medias.maxrows *= 2;
     }
diff -ruNp a/converter/ppm/ppmtopcx.c b/converter/ppm/ppmtopcx.c
--- a/converter/ppm/ppmtopcx.c	2021-06-02 15:53:59.846205765 +0200
+++ b/converter/ppm/ppmtopcx.c	2021-06-02 20:23:21.823634378 +0200
@@ -31,13 +31,13 @@
 #define PCX_MAXVAL      (pixval)255
 
 
-struct CmdlineInfo {
+struct cmdlineInfo {
     /* All the information the user supplied in the command line,
        in a form easy for the program to use.
     */
-    const char * inputFilespec;  /* '-' if stdin */
+    const char *inputFilespec;  /* '-' if stdin */
     unsigned int truecolor;   /* -24bit option */
-    unsigned int use8Bit; /* -8bit option */
+    unsigned int use_8_bit; /* -8bit option */
     unsigned int planes;    /* zero means minimum */
     unsigned int packed;
     unsigned int verbose;
@@ -49,16 +49,16 @@ struct CmdlineInfo {
 
 
 
-struct PcxCmapEntry {
+struct pcxCmapEntry {
     unsigned char r;
     unsigned char g;
     unsigned char b;
 };
 
-static struct PcxCmapEntry
+static struct pcxCmapEntry
 pcxCmapEntryFromPixel(pixel const colorPixel) {
 
-    struct PcxCmapEntry retval;
+    struct pcxCmapEntry retval;
 
     retval.r = PPM_GETR(colorPixel);
     retval.g = PPM_GETG(colorPixel);
@@ -70,8 +70,8 @@ pcxCmapEntryFromPixel(pixel const colorP
 
 
 static void
-parseCommandLine(int argc, const char ** argv,
-                 struct CmdlineInfo * const cmdlineP) {
+parseCommandLine(int argc, char ** argv,
+                 struct cmdlineInfo * const cmdlineP) {
 /*----------------------------------------------------------------------------
    parse program command line described in Unix standard form by argc
    and argv.  Return the information in the options as *cmdlineP.
@@ -82,7 +82,7 @@ parseCommandLine(int argc, const char **
    Note that the strings we return are stored in the storage that
    was passed to us as the argv array.  We also trash *argv.
 -----------------------------------------------------------------------------*/
-    optEntry * option_def;
+    optEntry *option_def;
         /* Instructions to pm_optParseOptions3 on how to parse our options.
          */
     optStruct3 opt;
@@ -97,7 +97,7 @@ parseCommandLine(int argc, const char **
     OPTENT3(0, "24bit",     OPT_FLAG,   NULL,
             &cmdlineP->truecolor,    0);
     OPTENT3(0, "8bit",      OPT_FLAG,   NULL,
-            &cmdlineP->use8Bit,    0);
+            &cmdlineP->use_8_bit,    0);
     OPTENT3(0, "planes",    OPT_UINT,   &cmdlineP->planes,
             &planesSpec,             0);
     OPTENT3(0, "packed",    OPT_FLAG,   NULL,
@@ -115,7 +115,7 @@ parseCommandLine(int argc, const char **
     opt.short_allowed = FALSE;  /* We have no short (old-fashioned) options */
     opt.allowNegNum = FALSE;  /* We have no parms that are negative numbers */
 
-    pm_optParseOptions3( &argc, (char **)argv, opt, sizeof(opt), 0 );
+    pm_optParseOptions3( &argc, argv, opt, sizeof(opt), 0 );
         /* Uses and sets argc, argv, and some of *cmdline_p and others. */
 
     if (!xposSpec)
@@ -141,7 +141,7 @@ parseCommandLine(int argc, const char **
             pm_error("-planes is meaningless with -packed.");
         if (cmdlineP->truecolor)
             pm_error("-planes is meaningless with -24bit");
-        if (cmdlineP->use8Bit)
+        if (cmdlineP->use_8_bit)
             pm_error("-planes is meaningless with -8bit");
     }
 
@@ -151,7 +151,7 @@ parseCommandLine(int argc, const char **
     if (!paletteSpec)
         cmdlineP->palette = NULL;
 
-    if (cmdlineP->use8Bit && cmdlineP->truecolor)
+    if (cmdlineP->use_8_bit && cmdlineP->truecolor)
         pm_error("You cannot specify both -8bit and -truecolor");
 
     if (argc-1 < 1)
@@ -172,8 +172,8 @@ parseCommandLine(int argc, const char **
  * Write out a two-byte little-endian word to the PCX file
  */
 static void
-putword(unsigned int const w,
-        FILE *       const fp) {
+Putword(int    const w,
+        FILE * const fp) {
 
     int rc;
 
@@ -189,13 +189,12 @@ putword(unsigned int const w,
  * Write out a byte to the PCX file
  */
 static void
-putbyte(unsigned int const b,
-        FILE *       const ofP) {
+Putbyte(int    const b,
+        FILE * const fp) {
 
     int rc;
 
-    rc = fputc(b & 0xff, ofP);
-
+    rc = fputc(b & 0xff, fp);
     if (rc == EOF)
         pm_error("Error writing byte to output file.");
 }
@@ -204,9 +203,9 @@ putbyte(unsigned int const b,
 
 static void
 extractPlane(unsigned char * const rawrow,
-             unsigned int    const cols,
+             int             const cols,
              unsigned char * const buf,
-             unsigned int    const plane) {
+             int             const plane) {
 /*----------------------------------------------------------------------------
    From the image row 'rawrow', which is an array of 'cols' palette indices
    (as unsigned 8 bit integers), extract plane number 'plane' and return
@@ -224,7 +223,9 @@ extractPlane(unsigned char * const rawro
 
     cp = buf;  /* initial value */
 
-    for (col = 0, cbit = 7, byteUnderConstruction = 0x00; col < cols; ++col) {
+    cbit = 7;
+    byteUnderConstruction = 0x00;
+    for (col = 0; col < cols; ++col) {
         if (rawrow[col] & planeMask)
             byteUnderConstruction |= (1 << cbit);
 
@@ -246,17 +247,14 @@ extractPlane(unsigned char * const rawro
 
 
 static void
-packBits(unsigned char * const rawrow,
-         unsigned int    const width,
+PackBits(unsigned char * const rawrow,
+         int             const width,
          unsigned char * const buf,
-         unsigned int    const bits) {
+         int             const bits) {
 
-    unsigned int x;
-    int i;
-    int shift;
+    int x, i, shift;
 
-    shift = -1;
-    i = -1;
+    shift = i = -1;
 
     for (x = 0; x < width; ++x) {
         if (shift < 0) {
@@ -272,73 +270,71 @@ packBits(unsigned char * const rawrow,
 
 
 static void
-writeHeader(FILE *              const ofP,
-            unsigned int        const cols,
-            unsigned int        const rows,
-            unsigned int        const bitsPerPixel,
-            unsigned int        const planes,
-            struct PcxCmapEntry const cmap16[],
-            unsigned int        const xPos,
-            unsigned int        const yPos) {
-
-    unsigned int bytesPerLine;
-
-    putbyte(PCX_MAGIC, ofP);        /* .PCX magic number            */
-    putbyte(0x05, ofP);             /* PC Paintbrush version        */
-    putbyte(0x01, ofP);             /* .PCX run length encoding     */
-    putbyte(bitsPerPixel, ofP);     /* bits per pixel               */
-
-    putword(xPos, ofP);             /* x1   - image left            */
-    putword(yPos, ofP);             /* y1   - image top             */
-    putword(xPos+cols-1, ofP);      /* x2   - image right           */
-    putword(yPos+rows-1, ofP);      /* y2   - image bottom          */
-
-    putword(cols, ofP);             /* horizontal resolution        */
-    putword(rows, ofP);             /* vertical resolution          */
+write_header(FILE *              const fp,
+             int                 const cols,
+             int                 const rows,
+             int                 const BitsPerPixel,
+             int                 const Planes,
+             struct pcxCmapEntry const cmap16[],
+             unsigned int        const xPos,
+             unsigned int        const yPos) {
+
+    int i, BytesPerLine;
+
+    Putbyte(PCX_MAGIC, fp);        /* .PCX magic number            */
+    Putbyte(0x05, fp);             /* PC Paintbrush version        */
+    Putbyte(0x01, fp);             /* .PCX run length encoding     */
+    Putbyte(BitsPerPixel, fp);     /* bits per pixel               */
+
+    Putword(xPos, fp);             /* x1   - image left            */
+    Putword(yPos, fp);             /* y1   - image top             */
+    Putword(xPos+cols-1, fp);      /* x2   - image right           */
+    Putword(yPos+rows-1, fp);      /* y2   - image bottom          */
+
+    Putword(cols, fp);             /* horizontal resolution        */
+    Putword(rows, fp);             /* vertical resolution          */
 
     /* Write out the Color Map for images with 16 colors or less */
-    if (cmap16) {
-        unsigned int i;
+    if (cmap16)
         for (i = 0; i < 16; ++i) {
-            putbyte(cmap16[i].r, ofP);
-            putbyte(cmap16[i].g, ofP);
-            putbyte(cmap16[i].b, ofP);
+            Putbyte(cmap16[i].r, fp);
+            Putbyte(cmap16[i].g, fp);
+            Putbyte(cmap16[i].b, fp);
         }
-    } else {
+    else {
         unsigned int i;
         for (i = 0; i < 16; ++i) {
-            putbyte(0, ofP);
-            putbyte(0, ofP);
-            putbyte(0, ofP);
+            Putbyte(0, fp);
+            Putbyte(0, fp);
+            Putbyte(0, fp);
         }
     }
-    putbyte(0, ofP);                /* reserved byte                */
-    putbyte(planes, ofP);           /* number of color planes       */
+    Putbyte(0, fp);                /* reserved byte                */
+    Putbyte(Planes, fp);           /* number of color planes       */
 
-    bytesPerLine = ((cols * bitsPerPixel) + 7) / 8;
-    putword(bytesPerLine, ofP);    /* number of bytes per scanline */
+    BytesPerLine = ((cols * BitsPerPixel) + 7) / 8;
+    Putword(BytesPerLine, fp);    /* number of bytes per scanline */
 
-    putword(1, ofP);                /* palette info                 */
+    Putword(1, fp);                /* palette info                 */
 
     {
         unsigned int i;
         for (i = 0; i < 58; ++i)        /* fill to end of header        */
-            putbyte(0, ofP);
+            Putbyte(0, fp);
     }
 }
 
 
 
 static void
-pcxEncode(FILE *                const ofP,
+PCXEncode(FILE *                const fp,
           const unsigned char * const buf,
-          unsigned int          const size) {
+          int                   const Size) {
 
-    const unsigned char * const end = buf + size;
+    const unsigned char * const end = buf + Size;
 
     const unsigned char * currentP;
-    unsigned int          previous;
-    unsigned int          count;
+    int previous, count;
 
     currentP = buf;
     previous = *currentP++;
@@ -351,19 +347,19 @@ pcxEncode(FILE *                const of
         else {
             if (count > 1 || (previous & 0xc0) == 0xc0) {
                 count |= 0xc0;
-                putbyte ( count , ofP );
+                Putbyte ( count , fp );
             }
-            putbyte(previous, ofP);
+            Putbyte(previous, fp);
             previous = c;
-            count = 1;
+            count   = 1;
         }
     }
 
     if (count > 1 || (previous & 0xc0) == 0xc0) {
         count |= 0xc0;
-        putbyte(count, ofP);
+        Putbyte ( count , fp );
     }
-    putbyte(previous, ofP);
+    Putbyte(previous, fp);
 }
 
 
@@ -390,46 +386,63 @@ indexOfColor(colorhash_table const cht,
 
 
 static void
-writeRaster16Color(FILE * const ofP,
-                   pixel **            const pixels,
-                   unsigned int        const cols,
-                   unsigned int        const rows,
-                   unsigned int        const planes,
-                   colorhash_table     const cht,
-                   bool                const packbits,
-                   unsigned int        const bitsPerPixel) {
-
-    unsigned int const bytesPerLine = ((cols * bitsPerPixel) + 7) / 8;
-
-    unsigned char * indexRow;  /* malloc'ed */
-    /* indexRow[x] is the palette index of the pixel at column x of
-       the row currently being processed
-    */
-    unsigned char * planesrow; /* malloc'ed */
-    /* This is the input for a single row to the compressor */
+ppmTo16ColorPcx(pixel **            const pixels,
+                int                 const cols,
+                int                 const rows,
+                struct pcxCmapEntry const pcxcmap[],
+                int                 const colors,
+                colorhash_table     const cht,
+                bool                const packbits,
+                unsigned int        const planesRequested,
+                unsigned int        const xPos,
+                unsigned int        const yPos) {
 
-    unsigned int row;
+    int Planes, BytesPerLine, BitsPerPixel;
+    unsigned char *indexRow;  /* malloc'ed */
+        /* indexRow[x] is the palette index of the pixel at column x of
+           the row currently being processed
+        */
+    unsigned char *planesrow; /* malloc'ed */
+        /* This is the input for a single row to the compressor */
+    int row;
 
+    if (packbits) {
+        Planes = 1;
+        if (colors > 4)        BitsPerPixel = 4;
+        else if (colors > 2)   BitsPerPixel = 2;
+        else                   BitsPerPixel = 1;
+    } else {
+        BitsPerPixel = 1;
+        if (planesRequested)
+            Planes = planesRequested;
+        else {
+            if (colors > 8)        Planes = 4;
+            else if (colors > 4)   Planes = 3;
+            else if (colors > 2)   Planes = 2;
+            else                   Planes = 1;
+        }
+    }
+    overflow2(BitsPerPixel, cols);
+    overflow_add(BitsPerPixel * cols, 7);
+    BytesPerLine = ((cols * BitsPerPixel) + 7) / 8;
     MALLOCARRAY_NOFAIL(indexRow, cols);
-    MALLOCARRAY(planesrow, bytesPerLine);
-
-    if (!planesrow)
-        pm_error("Failed to allocate buffer for a line of %u bytes",
-                 bytesPerLine);
+    MALLOCARRAY_NOFAIL(planesrow, BytesPerLine);
 
+    write_header(stdout, cols, rows, BitsPerPixel, Planes, pcxcmap,
+                 xPos, yPos);
     for (row = 0; row < rows; ++row) {
-        unsigned int col;
+        int col;
         for (col = 0; col < cols; ++col)
             indexRow[col] = indexOfColor(cht, pixels[row][col]);
 
         if (packbits) {
-            packBits(indexRow, cols, planesrow, bitsPerPixel);
-            pcxEncode(ofP, planesrow, bytesPerLine);
+            PackBits(indexRow, cols, planesrow, BitsPerPixel);
+            PCXEncode(stdout, planesrow, BytesPerLine);
         } else {
             unsigned int plane;
-            for (plane = 0; plane < planes; ++plane) {
+            for (plane = 0; plane < Planes; ++plane) {
                 extractPlane(indexRow, cols, planesrow, plane);
-                pcxEncode(stdout, planesrow, bytesPerLine);
+                PCXEncode(stdout, planesrow, BytesPerLine);
             }
         }
     }
@@ -439,143 +452,84 @@ writeRaster16Color(FILE * const ofP,
 
 
 
-static void
-ppmTo16ColorPcx(pixel **            const pixels,
-                unsigned int        const cols,
-                unsigned int        const rows,
-                struct PcxCmapEntry const pcxcmap[],
-                unsigned int        const colorCt,
-                colorhash_table     const cht,
-                bool                const packbits,
-                unsigned int        const planesRequested,
-                unsigned int        const xPos,
-                unsigned int        const yPos) {
-
-    unsigned int planes;
-    unsigned int bitsPerPixel;
-
-    if (packbits) {
-        planes = 1;
-        if (colorCt > 4)        bitsPerPixel = 4;
-        else if (colorCt > 2)   bitsPerPixel = 2;
-        else                    bitsPerPixel = 1;
-    } else {
-        bitsPerPixel = 1;
-        if (planesRequested)
-            planes = planesRequested;
-        else {
-            if (colorCt > 8)        planes = 4;
-            else if (colorCt > 4)   planes = 3;
-            else if (colorCt > 2)   planes = 2;
-            else                   planes = 1;
-        }
-    }
-
-    writeHeader(stdout, cols, rows, bitsPerPixel, planes, pcxcmap,
-                xPos, yPos);
-
-    writeRaster16Color(stdout, pixels, cols, rows, planes, cht, packbits,
-                       bitsPerPixel);
-}
-
-
-
 static void
 ppmTo256ColorPcx(pixel **            const pixels,
-                 unsigned int        const cols,
-                 unsigned int        const rows,
-                 struct PcxCmapEntry const pcxcmap[],
-                 unsigned int        const colorCt,
+                 int                 const cols,
+                 int                 const rows,
+                 struct pcxCmapEntry const pcxcmap[],
+                 int                 const colors,
                  colorhash_table     const cht,
                  unsigned int        const xPos,
                  unsigned int        const yPos) {
 
-    unsigned char * rawrow;
-    unsigned int    row;
-
-    MALLOCARRAY(rawrow, cols);
+    int row;
+    unsigned int i;
+    unsigned char *rawrow;
 
-    if (!rawrow)
-        pm_error("Failed to allocate a buffer for %u columns", cols);
+    rawrow = (unsigned char *)pm_allocrow(cols, sizeof(unsigned char));
 
     /* 8 bits per pixel, 1 plane */
-    writeHeader(stdout, cols, rows, 8, 1, NULL, xPos, yPos);
+    write_header(stdout, cols, rows, 8, 1, NULL, xPos, yPos);
     for (row = 0; row < rows; ++row) {
-        unsigned int col;
+        int col;
         for (col = 0; col < cols; ++col)
             rawrow[col] = indexOfColor(cht, pixels[row][col]);
-        pcxEncode(stdout, rawrow, cols);
-
+        PCXEncode(stdout, rawrow, cols);
     }
-    putbyte(PCX_256_COLORS, stdout);
-
-    {
-        unsigned int i;
-
-        for (i = 0; i < MAXCOLORS; ++i) {
-            putbyte(pcxcmap[i].r, stdout);
-            putbyte(pcxcmap[i].g, stdout);
-            putbyte(pcxcmap[i].b, stdout);
-        }
+    Putbyte(PCX_256_COLORS, stdout);
+    for (i = 0; i < MAXCOLORS; ++i) {
+        Putbyte(pcxcmap[i].r, stdout);
+        Putbyte(pcxcmap[i].g, stdout);
+        Putbyte(pcxcmap[i].b, stdout);
     }
-    free(rawrow);
+    pm_freerow((void*)rawrow);
 }
 
 
 
 static void
 ppmToTruecolorPcx(pixel **     const pixels,
-                  unsigned int const cols,
-                  unsigned int const rows,
+                  int          const cols,
+                  int          const rows,
                   pixval       const maxval,
                   unsigned int const xPos,
                   unsigned int const yPos) {
 
-    unsigned char * redrow;
-    unsigned char * grnrow;
-    unsigned char * blurow;
-    unsigned int    row;
+    unsigned char *redrow, *greenrow, *bluerow;
+    int col, row;
 
-    MALLOCARRAY(redrow, cols);
-    MALLOCARRAY(grnrow, cols);
-    MALLOCARRAY(blurow, cols);
-
-    if (!redrow || !grnrow || !blurow)
-        pm_error("Unable to allocate buffer for a row of %u pixels", cols);
+    redrow   = (unsigned char *)pm_allocrow(cols, sizeof(unsigned char));
+    greenrow = (unsigned char *)pm_allocrow(cols, sizeof(unsigned char));
+    bluerow  = (unsigned char *)pm_allocrow(cols, sizeof(unsigned char));
 
     /* 8 bits per pixel, 3 planes */
-    writeHeader(stdout, cols, rows, 8, 3, NULL, xPos, yPos);
-
-    for (row = 0; row < rows; ++row) {
-        pixel * const pixrow = pixels[row];
-
-        unsigned int col;
-
-        for (col = 0; col < cols; ++col) {
-            pixel const pix = pixrow[col];
-
-            if (maxval != PCX_MAXVAL) {
-                redrow[col] = (long)PPM_GETR(pix) * PCX_MAXVAL / maxval;
-                grnrow[col] = (long)PPM_GETG(pix) * PCX_MAXVAL / maxval;
-                blurow[col] = (long)PPM_GETB(pix) * PCX_MAXVAL / maxval;
-            } else {
-                redrow[col] = PPM_GETR(pix);
-                grnrow[col] = PPM_GETG(pix);
-                blurow[col] = PPM_GETB(pix);
+    write_header(stdout, cols, rows, 8, 3, NULL, xPos, yPos);
+    for( row = 0; row < rows; row++ ) {
+        register pixel *pP = pixels[row];
+        for( col = 0; col < cols; col++, pP++ ) {
+            if( maxval != PCX_MAXVAL ) {
+                redrow[col]   = (long)PPM_GETR(*pP) * PCX_MAXVAL / maxval;
+                greenrow[col] = (long)PPM_GETG(*pP) * PCX_MAXVAL / maxval;
+                bluerow[col]  = (long)PPM_GETB(*pP) * PCX_MAXVAL / maxval;
+            }
+            else {
+                redrow[col]   = PPM_GETR(*pP);
+                greenrow[col] = PPM_GETG(*pP);
+                bluerow[col]  = PPM_GETB(*pP);
             }
         }
-        pcxEncode(stdout, redrow, cols);
-        pcxEncode(stdout, grnrow, cols);
-        pcxEncode(stdout, blurow, cols);
+        PCXEncode(stdout, redrow, cols);
+        PCXEncode(stdout, greenrow, cols);
+        PCXEncode(stdout, bluerow, cols);
     }
-    free(blurow);
-    free(grnrow);
-    free(redrow);
+    pm_freerow((void*)bluerow);
+    pm_freerow((void*)greenrow);
+    pm_freerow((void*)redrow);
 }
 
 
 
-static const struct PcxCmapEntry
+static const struct pcxCmapEntry
 stdPalette[] = {
     {   0,   0,   0 },
     {   0,   0, 170 },
@@ -653,19 +607,20 @@ putPcxColorInHash(colorhash_table const
 
 
 static void
-generateStandardPalette(struct PcxCmapEntry ** const pcxcmapP,
+generateStandardPalette(struct pcxCmapEntry ** const pcxcmapP,
                         pixval                 const maxval,
                         colorhash_table *      const chtP,
-                        unsigned int *         const colorsP) {
+                        int *                  const colorsP) {
 
     unsigned int const stdPaletteSize = 16;
-
-    unsigned int          colorIndex;
-    struct PcxCmapEntry * pcxcmap;
-    colorhash_table       cht;
+    unsigned int colorIndex;
+    struct pcxCmapEntry * pcxcmap;
+    colorhash_table cht;
 
     MALLOCARRAY_NOFAIL(pcxcmap, MAXCOLORS);
 
+    *pcxcmapP = pcxcmap;
+
     cht = ppm_alloccolorhash();
 
     for (colorIndex = 0; colorIndex < stdPaletteSize; ++colorIndex) {
@@ -692,7 +647,6 @@ generateStandardPalette(struct PcxCmapEn
         pcxcmap[colorIndex].b = 0;
     }
 
-    *pcxcmapP = pcxcmap;
     *chtP = cht;
     *colorsP = stdPaletteSize;
 }
@@ -721,10 +675,11 @@ readPpmPalette(const char *   const pale
                  *paletteSizeP, MAXCOLORS);
 
     {
-        unsigned int j;
-        unsigned int row;
-        for (row = 0, j = 0; row < rows; ++row) {
-            unsigned int col;
+        int j;
+        int row;
+        j = 0;  /* initial value */
+        for (row = 0; row < rows; ++row) {
+            int col;
             for (col = 0; col < cols; ++col)
                 (*ppmPaletteP)[j++] = pixels[row][col];
         }
@@ -735,16 +690,16 @@ readPpmPalette(const char *   const pale
 
 
 static void
-readPaletteFromFile(struct PcxCmapEntry ** const pcxcmapP,
+readPaletteFromFile(struct pcxCmapEntry ** const pcxcmapP,
                     const char *           const paletteFileName,
                     pixval                 const maxval,
                     colorhash_table *      const chtP,
-                    unsigned int *         const colorsP) {
+                    int *                  const colorsP) {
 
     unsigned int colorIndex;
     pixel ppmPalette[MAXCOLORS];
     unsigned int paletteSize;
-    struct PcxCmapEntry * pcxcmap;
+    struct pcxCmapEntry * pcxcmap;
     colorhash_table cht;
 
     readPpmPalette(paletteFileName, &ppmPalette, &paletteSize);
@@ -777,7 +732,7 @@ readPaletteFromFile(struct PcxCmapEntry
 
 static void
 moveBlackToIndex0(colorhist_vector const chv,
-                  unsigned int     const colorCt) {
+                  int              const colors) {
 /*----------------------------------------------------------------------------
    If black is in the palette, make it at Index 0.
 -----------------------------------------------------------------------------*/
@@ -789,7 +744,7 @@ moveBlackToIndex0(colorhist_vector const
 
     blackPresent = FALSE;  /* initial assumption */
 
-    for (i = 0; i < colorCt; ++i)
+    for (i = 0; i < colors; ++i)
         if (PPM_EQUAL(chv[i].color, blackPixel))
             blackPresent = TRUE;
 
@@ -798,11 +753,10 @@ moveBlackToIndex0(colorhist_vector const
            beginning of the table and if the color is already elsewhere in
            the table, removes it.
         */
-        int colorCt2;
-
-        colorCt2 = colorCt;
-        ppm_addtocolorhist(chv, &colorCt2, MAXCOLORS, &blackPixel, 0, 0);
-        assert(colorCt2 == colorCt);
+        int colors2;
+        colors2 = colors;
+        ppm_addtocolorhist(chv, &colors2, MAXCOLORS, &blackPixel, 0, 0);
+        assert(colors2 == colors);
     }
 }
 
@@ -810,12 +764,12 @@ moveBlackToIndex0(colorhist_vector const
 
 static void
 makePcxColormapFromImage(pixel **               const pixels,
-                         unsigned int           const cols,
-                         unsigned int           const rows,
+                         int                    const cols,
+                         int                    const rows,
                          pixval                 const maxval,
-                         struct PcxCmapEntry ** const pcxcmapP,
+                         struct pcxCmapEntry ** const pcxcmapP,
                          colorhash_table *      const chtP,
-                         unsigned int *         const colorCtP,
+                         int *                  const colorsP,
                          bool *                 const tooManyColorsP) {
 /*----------------------------------------------------------------------------
    Make a colormap (palette) for the PCX header that can be used
@@ -831,29 +785,29 @@ makePcxColormapFromImage(pixel **
    Iff there are too many colors to do that (i.e. more than 256),
    return *tooManyColorsP == TRUE.
 -----------------------------------------------------------------------------*/
-    int colorCt;
+    int colors;
     colorhist_vector chv;
 
     pm_message("computing colormap...");
 
-    chv = ppm_computecolorhist(pixels, cols, rows, MAXCOLORS, &colorCt);
+    chv = ppm_computecolorhist(pixels, cols, rows, MAXCOLORS, &colors);
     if (chv == NULL)
         *tooManyColorsP = TRUE;
     else {
-        unsigned int i;
-        struct PcxCmapEntry * pcxcmap;
+        int i;
+        struct pcxCmapEntry * pcxcmap;
 
         *tooManyColorsP = FALSE;
 
-        pm_message("%d colors found", colorCt);
+        pm_message("%d colors found", colors);
 
-        moveBlackToIndex0(chv, colorCt);
+        moveBlackToIndex0(chv, colors);
 
         MALLOCARRAY_NOFAIL(pcxcmap, MAXCOLORS);
 
         *pcxcmapP = pcxcmap;
 
-        for (i = 0; i < colorCt; ++i) {
+        for (i = 0; i < colors; ++i) {
             pixel p;
 
             PPM_DEPTH(p, chv[i].color, maxval, PCX_MAXVAL);
@@ -870,9 +824,9 @@ makePcxColormapFromImage(pixel **
             pcxcmap[i].b = 0;
         }
 
-        *chtP = ppm_colorhisttocolorhash(chv, colorCt);
+        *chtP = ppm_colorhisttocolorhash(chv, colors);
 
-        *colorCtP = colorCt;
+        *colorsP = colors;
 
         ppm_freecolorhist(chv);
     }
@@ -882,43 +836,43 @@ makePcxColormapFromImage(pixel **
 
 static void
 ppmToPalettePcx(pixel **            const pixels,
-                unsigned int        const cols,
-                unsigned int        const rows,
+                int                 const cols,
+                int                 const rows,
                 pixval              const maxval,
                 unsigned int        const xPos,
                 unsigned int        const yPos,
-                struct PcxCmapEntry const pcxcmap[],
+                struct pcxCmapEntry const pcxcmap[],
                 colorhash_table     const cht,
-                unsigned int        const colorCt,
+                int                 const colors,
                 bool                const packbits,
                 unsigned int        const planes,
-                bool                const use8Bit) {
+                bool                const use_8_bit) {
 
     /* convert image */
-    if (colorCt <= 16 && !use8Bit )
-        ppmTo16ColorPcx(pixels, cols, rows, pcxcmap, colorCt, cht,
+    if( colors <= 16 && !use_8_bit )
+        ppmTo16ColorPcx(pixels, cols, rows, pcxcmap, colors, cht,
                         packbits, planes, xPos, yPos);
     else
-        ppmTo256ColorPcx(pixels, cols, rows, pcxcmap, colorCt, cht,
+        ppmTo256ColorPcx(pixels, cols, rows, pcxcmap, colors, cht,
                          xPos, yPos);
 }
 
 
 
 int
-main(int argc, const char *argv[]) {
+main(int argc, char *argv[]) {
 
-    struct CmdlineInfo cmdline;
-    FILE * ifP;
+    struct cmdlineInfo cmdline;
+    FILE* ifP;
     int rows, cols;
     pixval maxval;
     pixel **pixels;
-    struct PcxCmapEntry * pcxcmap;
+    struct pcxCmapEntry * pcxcmap;
     colorhash_table cht;
     bool truecolor;
-    unsigned int colorCt;
+    int colors;
 
-    pm_proginit(&argc, argv);
+    ppm_init(&argc, argv);
 
     parseCommandLine(argc, argv, &cmdline);
 
@@ -931,15 +885,15 @@ main(int argc, const char *argv[]) {
     else {
         if (cmdline.stdpalette) {
             truecolor = FALSE;
-            generateStandardPalette(&pcxcmap, maxval, &cht, &colorCt);
+            generateStandardPalette(&pcxcmap, maxval, &cht, &colors);
         } else if (cmdline.palette) {
             truecolor = FALSE;
             readPaletteFromFile(&pcxcmap, cmdline.palette, maxval,
-                                &cht, &colorCt);
+                                &cht, &colors);
         } else {
             bool tooManyColors;
             makePcxColormapFromImage(pixels, cols, rows, maxval,
-                                     &pcxcmap, &cht, &colorCt,
+                                     &pcxcmap, &cht, &colors,
                                      &tooManyColors);
 
             if (tooManyColors) {
@@ -958,8 +912,8 @@ main(int argc, const char *argv[]) {
     else {
         ppmToPalettePcx(pixels, cols, rows, maxval,
                         cmdline.xpos, cmdline.ypos,
-                        pcxcmap, cht, colorCt, cmdline.packed,
-                        cmdline.planes, cmdline.use8Bit);
+                        pcxcmap, cht, colors, cmdline.packed,
+                        cmdline.planes, cmdline.use_8_bit);
 
         ppm_freecolorhash(cht);
         free(pcxcmap);
diff -ruNp a/converter/ppm/ppmtopict.c b/converter/ppm/ppmtopict.c
--- a/converter/ppm/ppmtopict.c	2021-06-02 15:53:59.846205765 +0200
+++ b/converter/ppm/ppmtopict.c	2021-06-02 20:23:21.824634387 +0200
@@ -450,6 +450,8 @@ main(int argc, const char ** argv) {
     putShort(stdout, 0);            /* mode */
 
     /* Finally, write out the data. */
+    overflow_add(cols/MAX_COUNT, 1);
+    overflow_add(cols, cols/MAX_COUNT+1);
     outBuf = malloc((unsigned)(cols+cols/MAX_COUNT+1));
     for (row = 0, oc = 0; row < rows; ++row) {
         unsigned int rowSize;
diff -ruNp a/converter/ppm/ppmtopj.c b/converter/ppm/ppmtopj.c
--- a/converter/ppm/ppmtopj.c	2021-06-02 15:53:59.845205755 +0200
+++ b/converter/ppm/ppmtopj.c	2021-06-02 20:23:21.824634387 +0200
@@ -179,6 +179,7 @@ char *argv[];
 	pixels = ppm_readppm( ifp, &cols, &rows, &maxval );
 
 	pm_close( ifp );
+        overflow2(cols,2);
 	obuf = (unsigned char *) pm_allocrow(cols, sizeof(unsigned char));
 	cbuf = (unsigned char *) pm_allocrow(cols * 2, sizeof(unsigned char));
 
diff -ruNp a/converter/ppm/ppmtopjxl.c b/converter/ppm/ppmtopjxl.c
--- a/converter/ppm/ppmtopjxl.c	2021-06-02 15:53:59.845205755 +0200
+++ b/converter/ppm/ppmtopjxl.c	2021-06-02 20:23:21.825634396 +0200
@@ -267,6 +267,9 @@ main(int argc, const char * argv[]) {
     if (maxval > PCL_MAXVAL)
         pm_error("color range too large; reduce with ppmcscale");
 
+    if (cols < 0 || rows < 0)
+        pm_error("negative size is not possible");
+
     /* Figure out the colormap. */
     pm_message("Computing colormap...");
     chv = ppm_computecolorhist(pixels, cols, rows, MAXCOLORS, &colors);
@@ -286,6 +289,8 @@ main(int argc, const char * argv[]) {
         case 0: /* direct mode (no palette) */
             bpp = bitsperpixel(maxval); /* bits per pixel */
             bpg = bpp; bpb = bpp;
+            overflow2(bpp, 3);
+            overflow_add(bpp*3, 7);
             bpp = (bpp*3+7)>>3;     /* bytes per pixel now */
             bpr = (bpp<<3)-bpg-bpb; 
             bpp *= cols;            /* bytes per row now */
@@ -295,9 +300,13 @@ main(int argc, const char * argv[]) {
         case 3: case 7: pclindex++;
         default:
             bpp = 8/pclindex;
+            overflow_add(cols, bpp);
+            if(bpp == 0)
+                pm_error("assert: no bpp");
             bpp = (cols+bpp-1)/bpp;      /* bytes per row */
         }
     }
+    overflow2(bpp,2);
     inrow = (char *)malloc((unsigned)bpp);
     outrow = (char *)malloc((unsigned)bpp*2);
     runcnt = (signed char *)malloc((unsigned)bpp);
diff -ruNp a/converter/ppm/ppmtowinicon.c b/converter/ppm/ppmtowinicon.c
--- a/converter/ppm/ppmtowinicon.c	2021-06-02 15:53:59.845205755 +0200
+++ b/converter/ppm/ppmtowinicon.c	2021-06-02 20:23:21.825634396 +0200
@@ -12,6 +12,7 @@
 
 #include <math.h>
 #include <string.h>
+#include <stdlib.h>
 
 #include "pm_c_util.h"
 #include "winico.h"
@@ -214,6 +215,7 @@ createAndBitmap (gray ** const ba, int c
    MALLOCARRAY_NOFAIL(rowData, rows);
    icBitmap->xBytes = xBytes;
    icBitmap->data   = rowData;
+   overflow2(xBytes, rows);
    icBitmap->size   = xBytes * rows;
    for (y=0;y<rows;y++) {
       u1 * row;
@@ -342,6 +344,7 @@ create4Bitmap (pixel ** const pa, int co
    MALLOCARRAY_NOFAIL(rowData, rows);
    icBitmap->xBytes = xBytes;
    icBitmap->data   = rowData;
+   overflow2(xBytes, rows);
    icBitmap->size   = xBytes * rows;
 
    for (y=0;y<rows;y++) {
@@ -402,6 +405,7 @@ create8Bitmap (pixel ** const pa, int co
    MALLOCARRAY_NOFAIL(rowData, rows);
    icBitmap->xBytes = xBytes;
    icBitmap->data   = rowData;
+   overflow2(xBytes, rows);
    icBitmap->size   = xBytes * rows;
 
    for (y=0;y<rows;y++) {
@@ -709,7 +713,11 @@ addEntryToIcon(MS_Ico       const MSIcon
     entry->bitcount      = bpp;
     entry->ih            = createInfoHeader(entry, xorBitmap, andBitmap);
     entry->colors        = palette->colors;
-    entry->size_in_bytes = 
+    overflow2(4, entry->color_count);
+    overflow_add(xorBitmap->size, andBitmap->size);
+    overflow_add(xorBitmap->size + andBitmap->size, 40);
+    overflow_add(xorBitmap->size + andBitmap->size + 40, 4 * entry->color_count);
+    entry->size_in_bytes =
         xorBitmap->size + andBitmap->size + 40 + (4 * entry->color_count);
     if (verbose) 
         pm_message("entry->size_in_bytes = %d + %d + %d = %d",
diff -ruNp a/converter/ppm/ppmtoxpm.c b/converter/ppm/ppmtoxpm.c
--- a/converter/ppm/ppmtoxpm.c	2021-06-02 15:53:59.846205765 +0200
+++ b/converter/ppm/ppmtoxpm.c	2021-06-02 20:23:21.826634405 +0200
@@ -198,6 +198,7 @@ genNumstr(unsigned int const input, int
     unsigned int i;
 
     /* Allocate memory for printed number.  Abort if error. */
+    overflow_add(digits, 1);
     if (!(str = (char *) malloc(digits + 1)))
         pm_error("out of memory");
 
@@ -315,6 +316,7 @@ genCmap(colorhist_vector const chv,
     unsigned int charsPerPixel;
     unsigned int xpmMaxval;
     
+    if (includeTransparent) overflow_add(ncolors, 1);
     MALLOCARRAY(cmap, cmapSize);
     if (cmapP == NULL)
         pm_error("Out of memory allocating %u bytes for a color map.",
diff -ruNp a/converter/ppm/qrttoppm.c b/converter/ppm/qrttoppm.c
--- a/converter/ppm/qrttoppm.c	2021-06-02 15:53:59.846205765 +0200
+++ b/converter/ppm/qrttoppm.c	2021-06-02 20:23:21.826634405 +0200
@@ -46,7 +46,7 @@ main( argc, argv )
 
     ppm_writeppminit( stdout, cols, rows, maxval, 0 );
     pixelrow = ppm_allocrow( cols );
-    buf = (unsigned char *) malloc( 3 * cols );
+    buf = (unsigned char *) malloc2( 3 , cols );
     if ( buf == (unsigned char *) 0 )
 	pm_error( "out of memory" );
 
diff -ruNp a/converter/ppm/sldtoppm.c b/converter/ppm/sldtoppm.c
--- a/converter/ppm/sldtoppm.c	2021-06-02 15:53:59.845205755 +0200
+++ b/converter/ppm/sldtoppm.c	2021-06-02 20:23:21.827634413 +0200
@@ -154,127 +154,85 @@ vscale(int * const px,
 
 
 
-static void
-upcase(const char * const sname,
-       char *       const uname) {
-
-    unsigned int i;
-    const char * ip;
-
-    for (i = 0, ip = sname; i < 31; ++i) {
-        char const ch = *ip++;
-
-        if (ch != EOS)
-            uname[i] = islower(ch) ? toupper(ch) : ch;
-    }
-    uname[i] = EOS;
-}
-
-
-
-static void
-skipBytes(FILE *       const fileP,
-          unsigned int const count) {
-
-    unsigned int i;
-
-    for (i = 0; i < count; ++i)
-        getc(fileP);
-}
-
-
-
-static void
-scanDirectory(FILE *       const slFileP,
-              long         const dirPos,
-              bool         const dirOnly,
-              const char * const uname,
-              bool *       const foundP) {
-/*----------------------------------------------------------------------------
-   Scan the directory at the current position in *slFileP, either listing
-   the directory ('dirOnly' true) or searching for a slide named
-   'uname' ('dirOnly' false).
-
-   'dirPos' is the offset in the file of the directory, i.e. the current
-   position of *slFileP.
-
-   In the latter case, return as *foundP whether the slide name is there.
------------------------------------------------------------------------------*/
-    bool found;
-    bool eof;
-    long pos;
-    unsigned char libent[36];
-
-    for (found = false, eof = false, pos = dirPos; !found && !eof; ) {
-        size_t readCt;
-        readCt = fread(libent, 36, 1, slFileP);
-        if (readCt != 1)
-            eof = true;
-        else {
-            /* The directory entry is 32 bytes of NUL-terminated slide name
-               followed by 4 bytes of offset of the next directory entry.
-            */
-            const char * const slideName = (const char *)(&libent[0]);
-            if (pm_strnlen(slideName, 32) == 32)
-                pm_error("Invalid input: slide name field is not "
-                         "nul-terminated");
-            else {
-                if (strlen(slideName) == 0)
-                    eof = true;
-                else {
-                    pos += 36;
-                    if (dirOnly) {
-                        pm_message("  %s", slideName);
-                    } else if (streq(slideName, uname)) {
-                        long const dpos =
-                            (((((libent[35] << 8) | libent[34]) << 8) |
-                              libent[33]) << 8) | libent[32];
-
-                        if ((slFileP == stdin) ||
-                            (fseek(slFileP, dpos, 0) == -1)) {
-
-                            skipBytes(slFileP, dpos - pos);
-                        }
-                        found = true;
-                    }
-                }
-            }
-        }
-    }
-    *foundP = found;
-}
-
 /*  SLIDEFIND  --  Find  a  slide  in  a  library  or,  if  DIRONLY is
            nonzero, print a directory listing of the  library.
            If  UCASEN  is nonzero, the requested slide name is
            converted to upper case. */
 
 static void
-slidefind(const char * const slideName,
-          bool         const dirOnly,
+slidefind(const char * const sname,
+          bool         const dironly,
           bool         const ucasen) {
 
-    char uname[32];  /* upper case translation of 'slideName' */
-    char header[32]; /* (supposed) header read from file */
+    char uname[32];
+    unsigned char libent[36];
+    long pos;
     bool found;
+    bool eof;
 
-    if (dirOnly)
+    if (dironly)
         pm_message("Slides in library:");
     else {
-        upcase(slideName, uname);
+        unsigned int i;
+        const char * ip;
+        
+        ip = sname; /* initial value */
+        
+        for (i = 0; i < 31; ++i) {
+            char const ch = *ip++;
+            if (ch == EOS)
+                break;
+
+            {
+                char const upperCh =
+                    ucasen && islower(ch) ? toupper(ch) : ch;
+                
+                uname[i] = upperCh;
+            }
+        }
+        uname[i] = EOS;
     }
 
     /* Read slide library header and verify. */
-
-    if ((fread(header, 32, 1, slfile) != 1) ||
-        (!STRSEQ(header, "AutoCAD Slide Library 1.0\r\n\32"))) {
+    
+    if ((fread(libent, 32, 1, slfile) != 1) ||
+        (!streq((char *)libent, "AutoCAD Slide Library 1.0\015\012\32"))) {
         pm_error("not an AutoCAD slide library file.");
     }
+    pos = 32;
+    
+    /* Search for a slide with the requested name or list the directory */
+    
+    for (found = false, eof = false; !found && !eof; ) {
+        size_t readCt;
+        readCt = fread(libent, 36, 1, slfile);
+        if (readCt != 1)
+            eof = true;
+        else if (strlen((char *)libent) == 0)
+            eof = true;
+    }
+    if (!eof) {
+        pos += 36;
+        if (dironly) {
+            pm_message("  %s", libent);
+        } else if (streq((char *)libent, uname)) {
+            long dpos;
+
+            dpos = (((((libent[35] << 8) | libent[34]) << 8) |
+                     libent[33]) << 8) | libent[32];
+
+            if ((slfile == stdin) || (fseek(slfile, dpos, 0) == -1)) {
+                dpos -= pos;
+        
+                while (dpos-- > 0)
+                    getc(slfile);
+            }
+            found = true;
+        }
+    }
 
-    scanDirectory(slfile, 32, dirOnly, ucasen ? uname : slideName, &found);
-
-    if (!found && !dirOnly)
-        pm_error("slide '%s' not in library.", slideName);
+    if (!found && !dironly)
+        pm_error("slide '%s' not in library.", sname);
 }
 
 
@@ -392,7 +350,7 @@ slider(slvecfn   slvec,
 
     /* Verify that slide format is compatible with this program. */
 
-    if (!STRSEQ(slfrof.slh, slhi.slh))
+    if (streq(slfrof.slh, slhi.slh))
         pm_error("this is not an AutoCAD slide file.");
 
     /* Verify that the number format and file level in the header  are
@@ -506,6 +464,8 @@ slider(slvecfn   slvec,
 
     /* Allocate image buffer and clear it to black. */
 
+    overflow_add(ixdots, 1);
+    overflow_add(iydots, 1);
     pixels = ppm_allocarray(pixcols = ixdots + 1, pixrows = iydots + 1);
     PPM_ASSIGN(rgbcolor, 0, 0, 0);
     ppmd_filledrectangle(pixels, pixcols, pixrows, pixmaxval, 0, 0,
diff -ruNp a/converter/ppm/ximtoppm.c b/converter/ppm/ximtoppm.c
--- a/converter/ppm/ximtoppm.c	2021-06-02 15:53:59.846205765 +0200
+++ b/converter/ppm/ximtoppm.c	2021-06-02 20:23:21.828634422 +0200
@@ -22,9 +22,7 @@
 #include "shhopt.h"
 #include "nstring.h"
 
-
-
-struct CmdlineInfo {
+struct cmdlineInfo {
     /* All the information the user supplied in the command line,
        in a form easy for the program to use.
     */
@@ -36,8 +34,8 @@ struct CmdlineInfo {
 
 
 static void
-parseCommandLine(int argc, const char ** argv,
-                 struct CmdlineInfo *cmdlineP) {
+parseCommandLine(int argc, char ** argv,
+                 struct cmdlineInfo *cmdlineP) {
 /*----------------------------------------------------------------------------
    Note that many of the strings that this function returns in the
    *cmdlineP structure are actually in the supplied argv array.  And
@@ -59,7 +57,7 @@ parseCommandLine(int argc, const char **
     opt.short_allowed = FALSE;  /* We have no short (old-fashioned) options */
     opt.allowNegNum = FALSE;  /* We have no parms that are negative numbers */
 
-    pm_optParseOptions3(&argc, (char**)argv, opt, sizeof(opt), 0);
+    pm_optParseOptions3(&argc, argv, opt, sizeof(opt), 0);
         /* Uses and sets argc, argv, and all of *cmdlineP. */
 
     if (!alphaoutSpec)
@@ -102,11 +100,6 @@ ReadXimHeader(FILE *     const in_fp,
         pm_message("ReadXimHeader: unable to read file header" );
         return(0);
     }
-    /* Force broken ASCIIZ strings to at least be valid ASCIIZ */
-    a_head.author [sizeof(a_head.author)  - 1] = '\0';
-    a_head.date   [sizeof(a_head.date)    - 1] = '\0';
-    a_head.program[sizeof(a_head.program) - 1] = '\0';
-
     if (atoi(a_head.header_size) != sizeof(ImageHeader)) {
         pm_message("ReadXimHeader: header size mismatch" );
         return(0);
@@ -120,15 +113,39 @@ ReadXimHeader(FILE *     const in_fp,
     header->ncolors = atoi(a_head.num_colors);
     header->nchannels = atoi(a_head.num_channels);
     header->bytes_per_line = atoi(a_head.bytes_per_line);
-#if 0
-    header->npics = atoi(a_head.num_pictures);
-#endif
+/*    header->npics = atoi(a_head.num_pictures);
+*/
     header->bits_channel = atoi(a_head.bits_per_channel);
     header->alpha_flag = atoi(a_head.alpha_channel);
-    header->author = pm_strdup(a_head.author);
-    header->date = pm_strdup(a_head.date);
-    header->program = pm_strdup(a_head.program);
-
+    if (strlen(a_head.author)) {
+        overflow_add(strlen(a_head.author),1);
+        if (!(header->author = calloc((unsigned int)strlen(a_head.author)+1,
+                1))) {
+            pm_message("ReadXimHeader: can't calloc author string" );
+            return(0);
+        }
+    header->width = atoi(a_head.image_width);
+        strncpy(header->author, a_head.author, strlen(a_head.author));
+    }
+    if (strlen(a_head.date)) {
+        overflow_add(strlen(a_head.date),1);
+        if (!(header->date =calloc((unsigned int)strlen(a_head.date)+1,1))){
+            pm_message("ReadXimHeader: can't calloc date string" );
+            return(0);
+        }
+    header->width = atoi(a_head.image_width);
+        strncpy(header->date, a_head.date, strlen(a_head.date));
+    }
+    if (strlen(a_head.program)) {
+        overflow_add(strlen(a_head.program),1);
+        if (!(header->program = calloc(
+                    (unsigned int)strlen(a_head.program) + 1, 1))) {
+            pm_message("ReadXimHeader: can't calloc program string" );
+            return(0);
+        }
+    header->width = atoi(a_head.image_width);
+        strncpy(header->program, a_head.program,strlen(a_head.program));
+    }
     /* Do double checking for backwards compatibility */
     if (header->npics == 0)
         header->npics = 1;
@@ -147,6 +164,7 @@ ReadXimHeader(FILE *     const in_fp,
     if (header->nchannels == 3 && header->bits_channel == 8)
         header->ncolors = 0;
     else if (header->nchannels == 1 && header->bits_channel == 8) {
+        overflow2(header->ncolors, sizeof(Color));
         header->colors = (Color *)calloc((unsigned int)header->ncolors,
                 sizeof(Color));
         if (header->colors == NULL) {
@@ -197,8 +215,7 @@ ReadImageChannel(FILE *         const in
         }
         /* return to the beginning of the next image's buffer */
         if (fseek(infp, marker, 0) == -1) {
-            pm_message("ReadImageChannel: can't fseek to location "
-                       "in image buffer");
+            pm_message("ReadImageChannel: can't fseek to location in image buffer" );
             return(0);
         }
         free((char *)line);
@@ -307,26 +324,28 @@ ReadXimImage(FILE *     const in_fp,
 ***********************************************************************/
 
 static int
-ReadXim(FILE *     const in_fp,
-        XimImage * const xim) {
-
+ReadXim(in_fp, xim)
+    FILE *in_fp;
+    XimImage *xim;
+{
     if (!ReadXimHeader(in_fp, xim)) {
         pm_message("can't read xim header" );
-        return 0;
-    } else if (!ReadXimImage(in_fp, xim)) {
+    return(0);
+    }
+    if (!ReadXimImage(in_fp, xim)) {
         pm_message("can't read xim data" );
-        return 0;
-    } else
-        return 1;
+    return(0);
+    }
+    return(1);
 }
 
 
 
 int
-main(int          argc,
-     const char **argv) {
+main(int argc,
+     char *argv[]) {
 
-    struct CmdlineInfo cmdline;
+    struct cmdlineInfo cmdline;
     FILE *ifP, *imageout_file, *alpha_file;
     XimImage xim;
     pixel *pixelrow, colormap[256];
@@ -338,7 +357,7 @@ main(int          argc,
     pixval maxval;
     bool success;
 
-    pm_proginit(&argc, argv);
+    ppm_init(&argc, argv);
 
     parseCommandLine(argc, argv, &cmdline);
 
diff -ruNp a/editor/pamcut.c b/editor/pamcut.c
--- a/editor/pamcut.c	2021-06-02 15:53:59.809205409 +0200
+++ b/editor/pamcut.c	2021-06-02 20:23:21.828634422 +0200
@@ -799,6 +799,8 @@ cutOneImage(FILE *             const ifP
 
     outpam = inpam;    /* Initial value -- most fields should be same */
     outpam.file   = ofP;
+    overflow_add(rightcol, 1);
+    overflow_add(bottomrow, 1);
     outpam.width  = rightcol - leftcol + 1;
     outpam.height = bottomrow - toprow + 1;
 
diff -ruNp a/editor/pnmgamma.c b/editor/pnmgamma.c
--- a/editor/pnmgamma.c	2021-06-02 15:53:59.805205371 +0200
+++ b/editor/pnmgamma.c	2021-06-02 20:23:21.829634431 +0200
@@ -596,6 +596,7 @@ createGammaTables(enum transferFunction
                   xelval **             const btableP) {
 
     /* Allocate space for the tables. */
+    overflow_add(maxval, 1);
     MALLOCARRAY(*rtableP, maxval+1);
     MALLOCARRAY(*gtableP, maxval+1);
     MALLOCARRAY(*btableP, maxval+1);
diff -ruNp a/editor/pnmhisteq.c b/editor/pnmhisteq.c
--- a/editor/pnmhisteq.c	2021-06-02 15:53:59.800205323 +0200
+++ b/editor/pnmhisteq.c	2021-06-02 20:23:21.829634431 +0200
@@ -107,6 +107,7 @@ computeLuminosityHistogram(xel * const *
     unsigned int pixelCount;
     unsigned int * lumahist;
 
+    overflow_add(maxval, 1);
     MALLOCARRAY(lumahist, maxval + 1);
     if (lumahist == NULL)
         pm_error("Out of storage allocating array for %u histogram elements",
diff --git a/editor/pnmpad.c b/editor/pnmpad.c
index 9fa9f9e..6b98204 100644
--- a/editor/pnmpad.c
+++ b/editor/pnmpad.c
@@ -654,6 +654,8 @@ main(int argc, const char ** argv) {
 
     computePadSizes(cmdline, cols, rows, &lpad, &rpad, &tpad, &bpad);
 
+    overflow_add(cols, lpad);
+    overflow_add(cols + lpad, rpad);
     newcols = cols + lpad + rpad;
 
     if (cmdline.reportonly)
diff -ruNp a/editor/pnmremap.c b/editor/pnmremap.c
--- a/editor/pnmremap.c	2021-06-02 15:53:59.809205409 +0200
+++ b/editor/pnmremap.c	2021-06-02 20:23:21.830634440 +0200
@@ -470,6 +470,7 @@ fserr_init(struct pam *   const pamP,
 
     unsigned int const fserrSize = pamP->width + 2;
 
+    overflow_add(pamP->width, 2);
     fserrP->width = pamP->width;
 
     MALLOCARRAY(fserrP->thiserr, pamP->depth);
@@ -508,6 +509,7 @@ floydInitRow(struct pam *   const pamP,
 
     unsigned int col;
 
+    overflow_add(pamP->width, 2);
     for (col = 0; col < pamP->width + 2; ++col) {
         unsigned int plane;
         for (plane = 0; plane < pamP->depth; ++plane)
diff -ruNp a/editor/pnmscalefixed.c b/editor/pnmscalefixed.c
--- a/editor/pnmscalefixed.c	2021-06-02 15:53:59.800205323 +0200
+++ b/editor/pnmscalefixed.c	2021-06-02 20:23:21.830634440 +0200
@@ -214,6 +214,7 @@ compute_output_dimensions(const struct c
                           const int rows, const int cols,
                           int * newrowsP, int * newcolsP) {
 
+    overflow2(rows, cols);
     if (cmdline.pixels) {
         if (rows * cols <= cmdline.pixels) {
             *newrowsP = rows;
@@ -265,6 +266,8 @@ compute_output_dimensions(const struct c
 
     if (*newcolsP < 1) *newcolsP = 1;
     if (*newrowsP < 1) *newrowsP = 1;
+
+    overflow2(*newcolsP, *newrowsP);
 }        
 
 
@@ -446,6 +449,9 @@ main(int argc, char **argv ) {
        unfilled.  We can address that by stretching, whereas the other
        case would require throwing away some of the input.
     */
+
+    overflow2(newcols, SCALE);
+    overflow2(newrows, SCALE);
     sxscale = SCALE * newcols / cols;
     syscale = SCALE * newrows / rows;
 
diff -ruNp a/editor/ppmdither.c b/editor/ppmdither.c
--- a/editor/ppmdither.c	2021-06-02 15:53:59.803205352 +0200
+++ b/editor/ppmdither.c	2021-06-02 20:23:21.831634448 +0200
@@ -356,6 +356,11 @@ dithMatrix(unsigned int const dithPower)
             (dithDim * sizeof(*dithMat)) + /* pointers */
             (dithDim * dithDim * sizeof(**dithMat)); /* data */
         
+
+        overflow2(dithDim, sizeof(*dithMat));
+        overflow3(dithDim, dithDim, sizeof(**dithMat));
+        overflow_add(dithDim * sizeof(*dithMat), dithDim * dithDim * sizeof(**dithMat));
+
         dithMat = malloc(dithMatSize);
         
         if (dithMat == NULL) 
diff -ruNp a/editor/specialty/pamoil.c b/editor/specialty/pamoil.c
--- a/editor/specialty/pamoil.c	2021-06-02 15:53:59.817205486 +0200
+++ b/editor/specialty/pamoil.c	2021-06-02 20:23:21.831634448 +0200
@@ -112,6 +112,7 @@ main(int argc, char *argv[] ) {
     tuples = pnm_readpam(ifp, &inpam, PAM_STRUCT_SIZE(tuple_type));
     pm_close(ifp);
 
+    overflow_add(inpam.maxval, 1);
     MALLOCARRAY(hist, inpam.maxval + 1);
     if (hist == NULL)
         pm_error("Unable to allocate memory for histogram.");
diff -ruNp a/lib/libpam.c b/lib/libpam.c
--- a/lib/libpam.c	2021-06-02 15:53:59.867205967 +0200
+++ b/lib/libpam.c	2021-06-02 20:23:21.832634457 +0200
@@ -225,7 +225,8 @@ allocPamRow(const struct pam * const pam
     unsigned int const bytesPerTuple = allocationDepth(pamP) * sizeof(sample);
     tuple * tuplerow;
 
-    tuplerow = malloc(pamP->width * (sizeof(tuple *) + bytesPerTuple));
+    overflow_add(sizeof(tuple *), bytesPerTuple);
+    tuplerow = malloc2(pamP->width, (sizeof(tuple *) + bytesPerTuple));
 
     if (tuplerow != NULL) {
         /* Now we initialize the pointers to the individual tuples
diff -ruNp a/lib/libpammap.c b/lib/libpammap.c
--- a/lib/libpammap.c	2021-06-02 15:53:59.867205967 +0200
+++ b/lib/libpammap.c	2021-06-02 20:23:00.658449503 +0200
@@ -108,6 +108,8 @@ allocTupleIntListItem(struct pam * const
     */
     struct tupleint_list_item * retval;
 
+    overflow2(pamP->depth, sizeof(sample));
+    overflow_add(sizeof(*retval)-sizeof(retval->tupleint.tuple), pamP->depth*sizeof(sample));
     unsigned int const size =
         sizeof(*retval) - sizeof(retval->tupleint.tuple)
         + pamP->depth * sizeof(sample);
diff -ruNp a/lib/libpm.c b/lib/libpm.c
--- a/lib/libpm.c	2021-06-02 15:53:59.867205967 +0200
+++ b/lib/libpm.c	2021-06-02 20:23:21.832634457 +0200
@@ -888,5 +888,53 @@ pm_parse_height(const char * const arg)
     return height;
 }
 
+/*
+ *	Maths wrapping
+ */
 
+void __overflow2(int a, int b)
+{
+        if(a < 0 || b < 0)
+                pm_error("object too large");
+        if(b == 0)
+                return;
+        if(a > INT_MAX / b)
+                pm_error("object too large");
+}
+
+void overflow3(int a, int b, int c)
+{
+        overflow2(a,b);
+        overflow2(a*b, c);
+}
+
+void overflow_add(int a, int b)
+{
+        if( a > INT_MAX - b)
+                pm_error("object too large");
+}
+
+void *malloc2(int a, int b)
+{
+        overflow2(a, b);
+        if(a*b == 0)
+                pm_error("Zero byte allocation");
+        return malloc(a*b);
+}
+
+void *malloc3(int a, int b, int c)
+{
+        overflow3(a, b, c);
+        if(a*b*c == 0)
+                pm_error("Zero byte allocation");
+        return malloc(a*b*c);
+}
+
+void *realloc2(void * a, int b, int c)
+{
+        overflow2(b, c);
+        if(b*c == 0)
+                pm_error("Zero byte allocation");
+        return realloc(a, b*c);
+}
 
diff -ruNp a/lib/pm.h b/lib/pm.h
--- a/lib/pm.h	2021-06-02 15:53:59.866205957 +0200
+++ b/lib/pm.h	2021-06-02 20:23:21.833634466 +0200
@@ -442,5 +442,12 @@ pm_parse_height(const char * const arg);
 }
 #endif
 
+void *malloc2(int, int);
+void *malloc3(int, int, int);
+#define overflow2(a,b) __overflow2(a,b)
+void __overflow2(int, int);
+void overflow3(int, int, int);
+void overflow_add(int, int);
+
 
 #endif
diff -ruNp a/other/pnmcolormap.c b/other/pnmcolormap.c
--- a/other/pnmcolormap.c	2021-06-02 15:53:59.882206111 +0200
+++ b/other/pnmcolormap.c	2021-06-02 20:23:21.833634466 +0200
@@ -1002,6 +1002,7 @@ colormapToSquare(struct pam * const pamP
             pamP->width = intsqrt;
         else
             pamP->width = intsqrt + 1;
+            overflow_add(intsqrt, 1);
     }
     {
         unsigned int const intQuotient = colormap.size / pamP->width;
diff --git a/urt/Runput.c b/urt/Runput.c
index 1a7f2f7..de2737b 100644
--- a/urt/Runput.c
+++ b/urt/Runput.c
@@ -202,6 +202,7 @@ RunSetup(rle_hdr * the_hdr)
     if ( the_hdr->background != 0 )
     {
         int i;
+        overflow_add(the_hdr->ncolors, 1);
         rle_pixel *background =
             (rle_pixel *)malloc( (unsigned)(the_hdr->ncolors + 1) );
         int *bg_color;
@@ -224,7 +225,7 @@ RunSetup(rle_hdr * the_hdr)
         /* Big-endian machines are harder */
         int i, nmap = (1 << the_hdr->cmaplen) *
                                the_hdr->ncmap;
-        char *h_cmap = (char *)malloc( nmap * 2 );
+        char *h_cmap = (char *)malloc2( nmap, 2 );
         if ( h_cmap == NULL )
         {
             fprintf( stderr,
diff --git a/urt/rle.h b/urt/rle.h
index 1e7ddd0..df45dd9 100644
--- a/urt/rle.h
+++ b/urt/rle.h
@@ -152,6 +152,17 @@ rle_hdr             /* End of typedef. */
  */
 extern rle_hdr rle_dflt_hdr;
 
+/*
+ * Provided by pm library
+ */
+
+extern void overflow_add(int, int);
+#define overflow2(a,b) __overflow2(a,b)
+extern void __overflow2(int, int);
+extern void overflow3(int, int, int);
+extern void *malloc2(int, int);
+extern void *malloc3(int, int, int);
+extern void *realloc2(void *, int, int);
 
 /* Declare RLE library routines. */
 
diff --git a/urt/rle_addhist.c b/urt/rle_addhist.c
index 45c3dbf..ef13973 100644
--- a/urt/rle_addhist.c
+++ b/urt/rle_addhist.c
@@ -70,13 +70,19 @@ rle_addhist(char *          argv[],
         return;
 
     length = 0;
-    for (i = 0; argv[i]; ++i)
+    for (i = 0; argv[i]; ++i) {
+        overflow_add(length, strlen(argv[i]));
+        overflow_add(length+1, strlen(argv[i]));
         length += strlen(argv[i]) +1;   /* length of each arg plus space. */
+    }
 
     time(&temp);
     timedate = ctime(&temp);
     length += strlen(timedate);        /* length of date and time in ASCII. */
 
+    overflow_add(strlen(padding), 4);
+    overflow_add(strlen(histoire), strlen(padding) + 4);
+    overflow_add(length, strlen(histoire) + strlen(padding) + 4);
     length += strlen(padding) + 3 + strlen(histoire) + 1;
         /* length of padding, "on "  and length of history name plus "="*/
     if (in_hdr) /* if we are interested in the old comments... */
@@ -84,8 +90,10 @@ rle_addhist(char *          argv[],
     else
         old = NULL;
 
-    if (old && *old)
+    if (old && *old) {
+        overflow_add(length, strlen(old));
         length += strlen(old);       /* add length if there. */
+    }
 
     ++length;                               /*Cater for the null. */
 
diff --git a/urt/rle_getrow.c b/urt/rle_getrow.c
index a24870a..0ba62c3 100644
--- a/urt/rle_getrow.c
+++ b/urt/rle_getrow.c
@@ -164,6 +164,7 @@ rle_get_setup(rle_hdr * const the_hdr) {
         char * cp;
 
         VAXSHORT(comlen, infile); /* get comment length */
+        overflow_add(comlen, 1);
         evenlen = (comlen + 1) & ~1;    /* make it even */
         if (evenlen) {
             MALLOCARRAY(comment_buf, evenlen);
diff --git a/urt/rle_hdr.c b/urt/rle_hdr.c
index 8ceaa9e..4c13037 100644
--- a/urt/rle_hdr.c
+++ b/urt/rle_hdr.c
@@ -148,7 +148,7 @@ rle_hdr_cp(rle_hdr * const fromHdrP,
     if (toHdrP->cmap) {
         size_t const size =
             toHdrP->ncmap * (1 << toHdrP->cmaplen) * sizeof(rle_map);
-        toHdrP->cmap = malloc(size);
+        toHdrP->cmap = malloc3(toHdrP->ncmap, 1<<toHdrP->cmaplen, sizeof(rle_map));
         if (!toHdrP->cmap)
             pm_error("Failed to allocate memory for %u color maps "
                      "of length %u", toHdrP->ncmap, 1 << toHdrP->cmaplen);
@@ -164,11 +164,16 @@ rle_hdr_cp(rle_hdr * const fromHdrP,
 
         /* Count the comments. */
         for (cp = toHdrP->comments, size = 0; *cp; ++cp)
+	{
+            overflow_add(size,1);
             ++size;
+        }
 
         /* Check if there are really any comments. */
         if (size > 0) {
+            overflow_add(size,1);
             ++size;     /* Copy the NULL pointer, too. */
+            overflow2(size, sizeof(char *));
             size *= sizeof(char *);
             toHdrP->comments = malloc(size);
             if (!toHdrP->comments)
diff -ruNp a/urt/rle_putcom.c b/urt/rle_putcom.c
--- a/urt/rle_putcom.c	2021-06-02 15:53:59.824205554 +0200
+++ b/urt/rle_putcom.c	2021-06-02 20:25:22.620707940 +0200
@@ -98,12 +98,14 @@ rle_putcom(const char * const value,
         const char * v;
         const char ** old_comments;
         int i;
-        for (i = 2, cp = the_hdr->comments; *cp != NULL; ++i, ++cp)
+        for (i = 2, cp = the_hdr->comments; *cp != NULL; ++i, ++cp) {
+            overflow_add(i, 1);
             if (match(value, *cp) != NULL) {
                 v = *cp;
                 *cp = value;
                 return v;
             }
+        }
         /* Not found */
         /* Can't realloc because somebody else might be pointing to this
          * comments block.  Of course, if this were true, then the
