diff -purN requests-ftp-0.3.1.orig/requests_ftp/ftp.py requests-ftp-0.3.1/requests_ftp/ftp.py
--- requests-ftp-0.3.1.orig/requests_ftp/ftp.py	2023-10-02 11:37:02.265791589 -0400
+++ requests-ftp-0.3.1/requests_ftp/ftp.py	2023-10-02 11:38:01.070198328 -0400
@@ -6,7 +6,6 @@ from requests.compat import urlparse
 from requests.hooks import dispatch_hook
 from requests import Response, codes
 from io import BytesIO
-import cgi
 import os
 import socket
 import logging
@@ -30,12 +29,6 @@ class FTPSession(requests.Session):
         content field contains the binary data.'''
         return self.request('RETR', url, **kwargs)
 
-    def stor(self, url, files=None, **kwargs):
-        '''Sends an FTP STOR to a given URL. Returns a Response object. Expects
-        to be given one file by the standard Requests method. The remote
-        filename will be given by the URL provided.'''
-        return self.request('STOR', url, files=files, **kwargs)
-
     def nlst(self, url, **kwargs):
         '''Sends an FTP NLST. Returns a Response object.'''
         return self.request('NLST', url, **kwargs)
@@ -54,30 +47,6 @@ def monkeypatch_session():
     return
 
 
-def parse_multipart_files(request):
-    '''Given a prepared reqest, return a file-like object containing the
-    original data. This is pretty hacky.'''
-    # Start by grabbing the pdict.
-    _, pdict = cgi.parse_header(request.headers['Content-Type'])
-
-    # Now, wrap the multipart data in a BytesIO buffer. This is annoying.
-    buf = BytesIO()
-    buf.write(request.body)
-    buf.seek(0)
-
-    # Parse the data. Simply take the first file.
-    data = cgi.parse_multipart(buf, pdict)
-    _, filedata = data.popitem()
-    buf.close()
-
-    # Get a BytesIO now, and write the file into it.
-    buf = BytesIO()
-    buf.write(''.join(filedata))
-    buf.seek(0)
-
-    return buf
-
-
 def data_callback_factory(variable):
     '''Returns a callback suitable for use by the FTP library. This callback
     will repeatedly save data into the variable provided to this function. This
@@ -180,7 +149,6 @@ class FTPAdapter(requests.adapters.BaseA
         # send the specific queries.
         self.func_table = {'LIST': self.list,
                            'RETR': self.retr,
-                           'STOR': self.stor,
                            'NLST': self.nlst,
                            'SIZE': self.size,
                            'HEAD': self.head,
@@ -359,30 +327,6 @@ class FTPAdapter(requests.adapters.BaseA
         response.status_code = codes.ok
         return response
 
-    def stor(self, path, request):
-        '''Executes the FTP STOR command on the given path.'''
-
-        # First, get the file handle. We assume (bravely)
-        # that there is only one file to be sent to a given URL. We also
-        # assume that the filename is sent as part of the URL, not as part of
-        # the files argument. Both of these assumptions are rarely correct,
-        # but they are easy.
-        data = parse_multipart_files(request)
-
-        # Split into the path and the filename.
-        path, filename = os.path.split(path)
-
-        # Switch directories and upload the data.
-        self.conn.cwd(path)
-        code = self.conn.storbinary('STOR ' + filename, data)
-
-        # Close the connection and build the response.
-        self.conn.close()
-
-        response = build_binary_response(request, BytesIO(), code)
-
-        return response
-
     def nlst(self, path, request):
         '''Executes the FTP NLST command on the given path.'''
         data = BytesIO()
